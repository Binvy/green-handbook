fasterxml 

	## 简介： 

		json相关工具类，可以用来进行 POJO-JSON之间的数据转换，即如其命名含义：jackson-databind。

	## 相关网址：

		[github](https://github.com/FasterXML/jackson-databind)

		[docs](https://github.com/FasterXML/jackson-docs)

	## 用法：


		### Get it!

			```xml
				<properties>
				  ...
				  <!-- Use the latest version whenever possible. -->
				  <jackson.version>2.10.0</jackson.version>
				  ...
				</properties>

				<dependencies>
				  ...
				  <dependency>
				    <groupId>com.fasterxml.jackson.core</groupId>
				    <artifactId>jackson-databind</artifactId>
				    <version>${jackson.version}</version>
				  </dependency>
				  ...
				</dependencies>
			```	

			-- 版本说明：

				Core components may rely on any methods included in the supported JDK 
					Minimum JDK version was 1.5 until (and including) version 2.3
					Minimum JDK version was 1.6 for Jackson 2.4 - 2.7 (inclusive) for all core components 
						Minimum is still 1.6 for jackson-annotations and jackson-core, for all remaining Jackson 2.x versions
					Minimum JDK version is 1.7 for Jackson 2.7 - 2.10 of jackson-databind and most non-core components

				Jackson-databind (this package) depends on the other two (annotations, streaming).

		### Use It!	

			#### POJOs to JSON and back

				```java

					// Note: can use getters/setters as well; here we just use public fields directly:
					public class MyValue {
					  public String name;
					  public int age;
					  // NOTE: if using getters/setters, can keep fields `protected` or `private`
					}

				```

				```java

					ObjectMapper mapper = new ObjectMapper(); // create once, reuse

					/* json -> pojo */

						MyValue value = mapper.readValue(new File("data.json"), MyValue.class);
						// or:
						value = mapper.readValue(new URL("http://some.com/api/entry.json"), MyValue.class);
						// or:
						value = mapper.readValue("{\"name\":\"Bob\", \"age\":13}", MyValue.class);


					/* pojo -> json */

						mapper.writeValue(new File("result.json"), myResultObject);
						// or:
						byte[] jsonBytes = mapper.writeValueAsBytes(myResultObject);
						// or:
						String jsonString = mapper.writeValueAsString(myResultObject);

				```

			#### Generic collections, Tree Model
			
				```java

					/* pojo -> collections */

						Map<String, Integer> scoreByName = mapper.readValue(jsonSource, Map.class);
						List<String> names = mapper.readValue(jsonSource, List.class);

						// and can obviously write out as well
						mapper.writeValue(new File("names.json"), names);

						Map<String, ResultValue> results = mapper.readValue(jsonSource,
						   new TypeReference<Map<String, ResultValue>>() { } );
						// why extra work? Java Type Erasure will prevent type detection otherwise	

					/* pojo <-> tree model */		

						// can be read as generic JsonNode, if it can be Object or Array; or,
						// if known to be Object, as ObjectNode, if array, ArrayNode etc:
						ObjectNode root = mapper.readTree("stuff.json");
						String name = root.get("name").asText();
						int age = root.get("age").asInt();

						// can modify as well: this adds child Object as property 'other', set property 'type'
						root.with("other").put("type", "student");
						String json = mapper.writeValueAsString(root);

						// with above, we end up with something like as 'json' String:
						// {
						//   "name" : "Bob", "age" : 13,
						//   "other" : {
						//      "type" : "student"
						//   }
						// }

				```	

			#### Streaming parser, generator
			
				```java

					JsonFactory f = mapper.getFactory(); // may alternatively construct directly too

					// First: write simple JSON output
					File jsonFile = new File("test.json");
					JsonGenerator g = f.createGenerator(jsonFile);
					// write JSON: { "message" : "Hello world!" }
					g.writeStartObject();
					g.writeStringField("message", "Hello world!");
					g.writeEndObject();
					g.close();

					// Second: read file back
					JsonParser p = f.createParser(jsonFile);

					JsonToken t = p.nextToken(); // Should be JsonToken.START_OBJECT
					t = p.nextToken(); // JsonToken.FIELD_NAME
					if ((t != JsonToken.FIELD_NAME) || !"message".equals(p.getCurrentName())) {
					   // handle error
					}
					t = p.nextToken();
					if (t != JsonToken.VALUE_STRING) {
					   // similarly
					}
					String msg = p.getText();
					System.out.printf("My message to you is: %s!\n", msg);
					p.close();

				```	

			#### configuration

				##### Commonly used Features
				
					```java

						// SerializationFeature for changing how JSON is written

							// to enable standard indentation ("pretty-printing"):
							mapper.enable(SerializationFeature.INDENT_OUTPUT);
							// to allow serialization of "empty" POJOs (no properties to serialize)
							// (without this setting, an exception is thrown in those cases)
							mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
							// to write java.util.Date, Calendar as number (timestamp):
							mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);

							// DeserializationFeature for changing how JSON is read as POJOs:

							// to prevent exception when encountering unknown property:
							mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
							// to allow coercion of JSON empty String ("") to null Object value:
							mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);

						// JsonParser.Feature for configuring parsing settings:

							// to allow C/C++ style comments in JSON (non-standard, disabled by default)
							// (note: with Jackson 2.5, there is also `mapper.enable(feature)` / `mapper.disable(feature)`)
							mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
							// to allow (non-standard) unquoted field names in JSON:
							mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
							// to allow use of apostrophes (single quotes), non standard
							mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);

							// JsonGenerator.Feature for configuring low-level JSON generation:

							// to force escaping of non-ASCII characters:
							mapper.configure(JsonGenerator.Feature.ESCAPE_NON_ASCII, true);	

					```	

				##### Annotations: 

					###### changing property names
				
						```java

							public class MyBean {
							   private String _name;

							   // without annotation, we'd get "theName", but we want "name":
							   @JsonProperty("name")
							   public String getTheName() { return _name; }

							   // note: it is enough to add annotation on just getter OR setter;
							   // so we can omit it here
							   public void setTheName(String n) { _name = n; }
							}

						```		

					###### Ignoring properties
					
						```java

							// means that if we see "foo" or "bar" in JSON, they will be quietly skipped
							// regardless of whether POJO has such properties
							@JsonIgnoreProperties({ "foo", "bar" })
							public class MyBean
							{
							   // will not be written as JSON; nor assigned from JSON:
							   @JsonIgnore
							   public String internal;

							   // no annotation, public field is read/written normally
							   public String external;

							   @JsonIgnore
							   public void setCode(int c) { _code = c; }

							   // note: will also be ignored because setter has annotation!
							   public int getCode() { return _code; }
							}


							public class ReadButDontWriteProps {
							   private String _name;
							   @JsonProperty public void setName(String n) { _name = n; }
							   @JsonIgnore public String getName() { return _name; }
							}
							// in this case, no "name" property would be written out (since 'getter' is ignored); 
							// but if "name" property was found from JSON, it would be assigned to POJO property!


						```	

					###### using custom constructor

						```java
					
							public class CtorBean
							{
							  public final String name;
							  public final int age;

							  @JsonCreator // constructor can be public, private, whatever
							  private CtorBean(@JsonProperty("name") String name,
							    @JsonProperty("age") int age)
							  {
							      this.name = name;
							      this.age = age;
							  }
							}	

							public class FactoryBean
							{
							    // fields etc omitted for brewity

							    @JsonCreator
							    public static FactoryBean create(@JsonProperty("name") String name) {
							      // construct and return an instance
							    }
							}

						```		

			#### fancier stuff, conversions

				```java

					// pojo -> pojo

						ResultType result = mapper.convertValue(sourceObject, ResultType.class);

					// Convert from List<Integer> to int[]

						List<Integer> sourceList = ...;
						int[] ints = mapper.convertValue(sourceList, int[].class);

					// Convert a POJO into Map!

						Map<String,Object> propertyMap = mapper.convertValue(pojoValue, Map.class);

					// ... and back

						PojoType pojo = mapper.convertValue(propertyMap, PojoType.class);

					// decode Base64! (default byte[] representation is base64-encoded String)

						String base64 = "TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlz";
						byte[] binary = mapper.convertValue(base64, byte[].class);

				```

