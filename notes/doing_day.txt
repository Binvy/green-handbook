# 2019-10-14 23:02:04

	# 离职申请 2019-10-28

	# 看LOL S9小组赛

# 2019-10-15 22:54:57

	# happy birthday

	# LOL S9	

# 2019-10-18 21:01:54	

	# LOL S9

		A-1 GRF
		A-2 G2

# 2019-10-19 11:56:20

	# Springboot 启动流程

	# SpringMVC 请求流程  // TODO


# 2019-10-22 22:44:08

	# inteview 3 companys

	# lol 2 games

# 2019-10-23 21:01:46

	# https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#beans-factory-class-instance-factory-method

		1.4.1 Dependency Resolution Process 

		1.5	 // todo

# 2019-10-26 10:00:34
	
	# 面试： 13:30

		北京源码酷教育科技有限公司		北京朝阳区SOHO现代城C座1201

		不想去。

# 2019-10-27 22:41:37

	# 早上看了会git面试题

	  下午LOL

	  晚上LOL比赛
	  
# 2019-10-29 19:04:06

	# 面试

		1. 大连华信 北辰世纪中心A座11层

			没戏。

		2. 东风系能源 西北旺东路10号东区12号楼和协科技大厦B座一层

			等通知

# 2019-10-30 20:35:23			

	# 面试

		软通动力————联想总部

			需springcloud，pass。

# 2019-10-31 20:35:13

	# 面试	

		am. 国亚通宝

			小小小外包，pass。

		pm. 京东————某外部
		
			只招中高级，pass。	

	# https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#spring-core // todo

# 2019-11-1 23:15:49

	# 面试 

		am. 雅睿捷 昌平区 珠江摩尔公园6号楼 1单元207

				面试问题：
					** mybatis后台分页

				面试结果：
					小小小公司，没人负责一个项目，pass。

		pm. 蓝卡 中关村软件园信息中心 1A306	15：00

				面试问题：
					工作经历...技术相关很少
		
				面试结果：
					新增研发部，面试题多数和linux系统有关，等通知（最晚周一下班前）。		

			阿里影业							20:00

				面试问题：

					** 自我介绍
					** 离职原因（诟病：做好自己的工作）
					** 项目相关。自己负责的疑难问题及解决方案。
					** http协议和udp协议的区别
					** arraylist和linkedlist的区别
					** 浏览器url请求的过程
					** jdk1.8 stream操作
					** hashmap和concurrenthashmap的区别
					** 平时学习的方式
					** springboot中一些starter是怎么加载的

				面试结果：

					差距很大。继续努力。

# 2019-11-5 19:35:48

	# 博思软件 am 10:00

		出差

		晚上7:00 电话面试	 PASS

	# 长久物流 pm 15:00	

		够呛 PASS

# 2019-11-6 16:27:08

	# 10：00 四方精创

		一面，可能缴纳的是深圳的五险一金，薪资面额 = 基本工资(40%) + 绩效(60%)。 PASS

	# 14:00  京北方 ==》 安定门-安德里北街（8号线直达）民生银行
	
		Offer薪资意愿：15K * 12 + 季度绩效（0.1%-1%）+ 餐补（20/d） = 15K+，两个月试用期。

# 2019-11-7 22:12:05

	# 10:00 上品盈嘉 北京朝阳区 富力双子座B座 1702 品刷刷	

		一面： 平时用的一些东西。 感觉还好。 

		相关工作： 营销相关 + 支付 + 小程序。开发团队3人。业务较多，会经常加班到8/9点。  等下周通知。

	# 14:30 联想总部 @ 软通动力

		第一个项目面试：

			设计模式、mybatis标签...		// 反馈：已通过面试 15K

		第二个项目面试：

			SQL、单例模式、二分查找、HashMap和ConcurrentHashMap		// 反馈：已通过面试 15K

# 2019-11-8 20:49:28

	# 京北方 入职 海淀区西三环北路25号 青政大厦7/8层 

# 2019-11-10 23:46:46

	# 恭喜FPX S9冠军			

# 2019-11-11 14:50:00

	# https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#beans-definition-profiles
	
		1. The IoC Container	// done 2019年11月11日 17点25分

# 2019-11-12 21:53:00

	# 入职相关工作：		

		OA办公系统: http://oa.northking.net
			登录名: binwei.han
		邮件系统: http://mail.northking.net 		
			邮箱地址: binwei.han@northking.net
		日志系统: http://bpowls.northking.net:7070/pm/
			登录名: binwei.han

		项目编号： RD-18-1386-03

		相关文档：
			C:\Users\hbw44\Downloads\考勤管理制度.docx
			C:\Users\hbw44\Downloads\员工手册201803版本.doc
			C:\Users\hbw44\Downloads\办公用品管理规定.docx

# 2019-11-13 10:14

	# 民生银行入场 

		1. 姓名:  韩斌伟
		2. 联系电话: 137 5233 0376
		3. 所在项目组名称: 中国民生银行信息科技部外部开发资源池公共资源框架采购项目
		4. 所在工作楼层: 6层(工位暂时未定)
		5. 行方项目经理: 王飞
		6. 行方经理联系方式: ‭186 0012 9523‬
		7. 所属地区: 安外
		8. 公司项目经理: 王飞
		9. 公司经理练习方式: 156 1410 8346

	# https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#core-convert

	  https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#validation // done 2019年11月13日 18点50分

# 2019-11-14 09:52:00 
	
	# 相关工作内容核实：

		公司这边：

			每天上下班手机APP打卡签到签退；
			每周四上报周报，行内邮箱发给小组长；
			每周五上报日志；
			每月20号左右提交项目外出申请（ito）流程，

			差不多就这些，我都会在群里提醒，关注一下就知道了

			OA系统：http://oa.northking.net
			邮箱：binwei.han@northking.net  邮箱服务器：mail.northking.net

		行方这边：

			每天上下班打卡，
			每月月初报预估报工，
			每月报工，

			主要这些，慢慢熟悉就行，有什么不懂的可以问一下小组长，小组长问一下王飞经理，看看王飞经理给你指派的是哪位小组长

	# https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#expressions // done 2019年11月14日 18点51分

# 2019-11-15 09:28:00
	
	# https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#aop

		5.4 @Aspect support // done 2019年11月15日 18点47分

# 2019-11-18 09:36:00

	# https://docs.spring.io/spring/docs/5.2.0.RELEASE/spring-framework-reference/core.html#aop-schema

		5 Aspect Oriented Programming with Spring // done 2019-11-18 17:10:00	

# 2019-11-25 23:16:15

	# https://github.com/hibernate/hibernate-demos		

		Hibernate ORM		// done 2019-11-25 23:16:55

		Hibernate OGM		// done just so so 2019-11-25 23:17:37

		Hibernate Search

		Hibernate Validator // done before 

		Java 9				// just soso 2019-11-25 23:17:57

		Other	

# 2019-11-30 22:26:57

	# spring + struts2 + mybatis整合

		+ struts2	// done 2019-11-30 22:27:21			

		+ mybatis 	// done 2019-12-1 19:37:17

		+ 前后端调用	// todo


# 2019-12-2 22:35:42

	# 看了一些私活平台，还是努力提高自身吧		// 2019-12-2 22:36:01

# 2019-12-5 22:50:19

	# lol	

# 2019-12-8 17:30 

	# build ssm project 						// done 

# 2019-12-9 18:50

	# activiti 									// todo

# 2019-12-10 21:47:24

	# 公司培训									// 周六TODO   done 2019-12-14 16:00

	# 电脑修理店拷贝硬盘资源						// 周末TODO   done 2019-12-15 20:00 

		硬盘已格式化，无内容

	# java优秀项目：								// TODO

		开源界“小普元”超越传统商业企业级开发平台: https://github.com/zhangdaiscott/jeecg-boot

		电商系统，包括前台商城系统及后台管理系统: https://github.com/macrozheng/mall

# 2019-12-11 22:28:01

	# boss系统重新搭建						

		计划：

			java:

				ac:						// 终端指令相关							// done 2019-12-12 22:31:08									

				activiti:				// activiti工作流							

				billing:				

				callcenter:				// doing

				crm:

				ocs:

				portal:

				res:

				rest:

				sms:

				task:

				util:

				web:

				weixin:

				ws:

			jsp:						// doing

2019-12-17 14:12:00

	# ObjectMapper()等json工具类转化总结 		// done 2019-12-17 22:59:38

		具体用法参考：

	# github 资源浏览						// todo 	

2019-12-19 18:51:00
	
	# hibernate Validator 				// todo done 2019-12-21 16:11:41

		条件必输校验；是否可以自定义校验注解	// done 2019-12-19 22:47:28

			official： 

				5.1.3.Final	https://docs.jboss.org/hibernate/validator/5.1/reference/en-US/html_single/#validator-gettingstarted-uel	// todo

		方案： com.binvi.springboot.demo03.validator.referenceguide.chapter03.validation.ConditionalRequiredTest
		
			可以添加，@ScriptAssert可用于List添加多条.i.e:

				@ScriptAssert.List({
						@ScriptAssert(lang = "javascript", script = "_this.type != 00 || !!_this.flag", message = "type为00时，flag不能为空"),
						@ScriptAssert(lang = "javascript", script = "_this.type != 00 || !!_this.flag2", message = "type为00时，flag2不能为空"),
						@ScriptAssert(lang = "javascript", script = "_this.type != 00 || !!_this.flag3", message = "type为00时，flag3不能为空"),
						@ScriptAssert(lang = "javascript", script = "_this.type != 00 || !!_this.flag4", message = "type为00时，flag4不能为空")
				})
				@Data
				public class DemoRequest {

					private String id;
					private String name;
					@Pattern(regexp = "00|01|02|03|04|05")
					private String type;
					private String flag;
					private String flag2;
					private String flag3;
					@Pattern(regexp = "11|12|13|14|15", message = "flag4必须在[{regexp}]之间取值")
					private String flag4;

				}

		方案2： 自定义校验器。（但是每个request都需要定义自己的校验器）

			i.e:

				@Documented
				@Constraint(validatedBy = ConditionalRequired.Validator.class)
				@Target({TYPE})
				@Retention(RUNTIME)
				@Repeatable(List.class)
				public @interface ConditionalRequired {

					String message() default "{com.binvi.springboot.demo03.validator.referenceguide.chapter03.annotation.ConditionalRequired.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };

					class Validator implements ConstraintValidator<ConditionalRequired, DemoRequest> {

						@Override
						public void initialize(ConditionalRequired constraintAnnotation) {

						}

						@Override
						public boolean isValid(DemoRequest request, ConstraintValidatorContext context) {
							if (request == null) {
								return true;
							}
							if (StringUtils.isEmpty(request.getType())) {
								return true;
							}
							return (!StringUtils.equals("01", request.getType()) || StringUtils.isNotEmpty(request.getFlag())) &&
									(!StringUtils.equals("01", request.getType()) || StringUtils.isNotEmpty(request.getFlag2())) &&
									(!StringUtils.equals("01", request.getType()) || StringUtils.isNotEmpty(request.getFlag3())) &&
									(!StringUtils.equals("01", request.getType()) || StringUtils.isNotEmpty(request.getFlag4()));
						}
					}

					@Target(TYPE)
					@Retention(RUNTIME)
					@Documented
					@interface List {
						ConditionalRequired[] value();
					}

				}

			tips： 
				
				If a ValidatorFactory instance is no longer in use, it should be disposed by calling ValidatorFactory#close(). This will free any resources possibly allocated by the factory.	

2019-12-20 21:03:37

	# LOL				 

2019-12-21 12:39:14

	# java 执行其他语言的脚本，如Javascript

		```java

			ScriptEngineManager scriptEngineManager = new ScriptEngineManager();
			ScriptEngine js = scriptEngineManager.getEngineByName("js");
			js.put("out", System.out);
			String script_js = "for (var i = 0; i < 10; i++) { out.println(i) }";
			System.out.println(js.eval(script_js));
			
		```		

2019-12-24 16:59:00

	# 查看jar包版本号：

		1. 使用UE直接查看class文件字节码

			CA FE BA BE 00 00 00 49

			其中，前8位（CA FE BA BE）为固定标识，后4位（00 00）为次版本号，再后4位（00 49）为jdk版本号

		2. 查看jar包打包信息
		
			xxx.jar/META-INF/MANIFEST.MF

			其中，Build-Jdk: 1.5.0_221 为jdk版本信息

		3. 解压jar包，任一class文件目录下执行cmd命令： javap -verbose xxxxx.class
		
			其中：major version: 49 为jdk版本信息	

		jdk版本信息：
		
			jdk版本号：		jdk1.2 		jdk1.3 		jdk1.4 		jdk1.5 		jdk1.6 		jdk1.7  	jdk1.8 

			十进制表示：	46          47          48          49          50          51          52

2019-12-25 21:22:12

	# bean map 转换测试：

			times				apache 				jackson				fastjson

			1					116					188					92
			10					3					10					1
			100					20					72					4
			1000				72					297					33
			10000				414					1099				53
			100000				4605				3922				142
			1000000				927366				25942				782		
			10000000			???					255503				7226
			100000000			???					???					???

			- java	 
			  	实现机制：java内省和反射
			  	优点：java内部类即可实现，无序引用外部类库。
			  	缺点：转换过程中需要自己对数据类型进行控制，简单的数据类型还好，如果数据类型复杂，实现代码也并不会很简易。
			- apache.common.beanutil
			  	实现机制：使用java反射机制实现
			  	优点：增加缓存操作，使用次数越多，效率越高（实际测试时，到10W、100W开始飙升，可能和本身jar包中的日志打印有关系，个人猜测日志应该不是主要原因），由于平时使用较少，暂未发现其他优点。
			  	缺点：（测试中发现对于非公开的类/读写方法，会导致反射读写异常，不确定这是不是所有基于java反射机制实现都会遇到问题），由于平时使用较少，暂未发现其他缺点。
			- jackson
			  	实现机制：使用序列化和反序列化实现
			  	优点：可配置性很高。（比如可以通过配置实现不同名称之间的转换）
			  	缺点：速度中规中矩，暂未发现其他缺点。
			- fastjson 
			  	实现机制：使用序列化和反序列化实现，解析json主要是用的String类substring，申请内存次数很少，所以解析起来非常“快”
			  	优点：测试中速度最快的。
			  	缺点： 代码质量较差，用很多投机取巧的的做法去实现所谓的“快”，而失去了原本应该兼容的java特性，对json标准遵循也不严格。

2019-12-28 16:18:05

	# spring-framework-reference 				 				//  2019-12-28 15:30:50	 	start

		https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/core.html#expressions-ref-functions

			Core Technologies									// done before

				9. Spring Expression Language(SPEL)				// done 2019-12-28 16:20:02

				10. Aspect Oriented Programming with Spring  	// done before

	# lol		

2019-12-30 21:34:31

	# Github > 12306-master										// done 2019-12-31 00:29:34

   		Cookie: 
   			JSESSIONID=7B15E0AE861C55835389B9457AFA243B; 
   			tk=Qid5F9W0OiqqJTN_8o-owoszQq7VwRBDTv7n_3xaBdY27h1h0; 
   			RAIL_DEVICEID=W7dqHWdSt_kBp317OEPJk5-8mZOIKluJ846Xuwf8gctujBV_S2LXppth2W4tcdlvwI-f1OY4bZ-MR14NgiGld9Fy4_VhBGjiRDM9mln-qhDo4geAvbfY5rOP5ZGGXyJkgjatVQP4-l4aZEsmNIFm9ebSYkPxeRIr; 
   			RAIL_EXPIRATION=1577979460246; 
   			route=40150bb70f80a8f2cae5d163d847c5e6; 
   			BIGipServerpool_excater=1273692682.32805.0000		

2020-1-1 00:10:47

	# LOL

	# 
			Happy New Year!!!!! 

	  		   新 年 快 乐！

2020-1-4 12:10:02

	# url: /passport/web/login返回参数为空, 接口状态码: 302	

2020-1-5 22:48:10

	# Spring MVC > 1. DispatherServlet				//  done 2020-1-5 10:00:02	  		   

	# LOL

2020-1-7 20:59:53

	# 	https://docs.spring.io/spring/docs/5.2.2.RELEASE/spring-framework-reference/web.htm

			1.3. Annotated Controllers				// done 2020-1-7 22:39:22

2020-1-8 22:07:04

	# 头疼，然后LOL，然后激情四射

2020-1-9 23:07:54

	# 抢了一张1-22号的无座票。	

2020-1-11 10:19:17	

	# 西直门

2020-1-12 23:19:32

	# LOL

2020-1-14 18:42:00

	# spring-framework-reference-4.3.24.pdf

		Part VI. The Web

			26 WebSocket Support 			// done2010-1-14 18:44
   			
2020-1-21 16：27：00

	# Spring中，properties文件的两种引入方式：(@Autowired, @Value导入为空时可以从这里进行排查)

		1. <util:properties>

			说明：以声明bean方式来使用，创建了一个bean，通过SpEL表达式#{}获取bean的属性

			示例：

				ApplicationContext.xml

					<util:properties location="classpath:com/foo/jdbc.properties" id="jdbcConfig"/>

				jdbc.properties
					
					jdbc.driverClassName=org.hsqldb.jdbcDriver
					jdbc.url=jdbc:hsqldb:hsql://production:9002
					jdbc.username=sa
					jdbc.password=root

				service
				
					@Value("#{jdbcConfig["jdbc.url"]}")
					private String url;

					@Value("#{jdbcConfig["jdbc.driverClassName"]}")
					private String driverClassName;

					@Value("#{jdbcConfig["jdbc.username"]}")
					private String username;

					@Value("#{jdbcConfig["jdbc.password"]}")
					private String password;		

		2. 	<context:property-placeholder>

			说明：将配置文件加载至spring上下文中，通过${}获取值，常用于bean的属性上。

			示例：

				ApplicationContext.xml

					<!-- 多个配置用逗号隔开 -->
					<context:property-placeholder location="classpath:com/foo/jdbc.properties,classpath:com/foo/env.properties"/>

					<!-- 等价于 -->
					<bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
						<property name="locations" value="classpath:com/foo/jdbc.properties,classpath:com/foo/env.properties">
					</bean>

					<!-- 等价于 -->
					<beans:bean class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer">
						<beans:properties name="locations">
							<beans:list>
								<bean:value>classpath:com/foo/jdbc.properties</bean:value>
								<bean:value>classpath:com/foo/env.properties</bean:value>
							</beans:list>
						</beans:properties>
					</beans:bean>

					<!-- 运行时使用 -->	
					<bean id="dataSource" destroy-method="close" class="org.apache.commons.dbcp.BasicDataSource">
						<property name="driverClassName" value="${jdbc.driverClassName}"/>
						<property name="url" value="${jdbc.url}"/>
						<property name="username" value="${jdbc.username}"/>
						<property name="password" value="${jdbc.password}"/>
					</bean>

				jdbc.properties
					
					jdbc.driverClassName=org.hsqldb.jdbcDriver
					jdbc.url=jdbc:hsqldb:hsql://production:9002
					jdbc.username=sa
					jdbc.password=root

				service
					
					@Value("${jdbc.url}")
					private String url;

					@Value("${jdbc.driverClassName}")
					private String driverClassName;

					@Value("${jdbc.username}")
					private String username;

					@Value("${jdbc.password}")
					private String password;	

2020-1-22 01:46:13

	# NARUTO download url： thunder://QUFtYWduZXQ6P3h0PXVybjpidGloOjYwRDE3RjFBQzAwNjY1MkZCNjY1QjM4QTE5OTM2QTZGNzdFRDU2RjVaWg==					

							magnet:?xt=urn:btih:60D17F1AC006652FB665B38A19936A6F77ED56F5

2020-2-7 14:16:44

	# idea永久注册码:							

		QYYBAC9D3J-eyJsaWNlbnNlSWQiOiJRWVlCQUM5RDNKIiwibGljZW5zZWVOYW1lIjoi6LaF57qnIOeoi+W6j+WRmCIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiIiLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9LHsiY29kZSI6IkFDIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9LHsiY29kZSI6IkRQTiIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJQUyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJHTyIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJETSIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJDTCIsImZhbGxiYWNrRGF0ZSI6IjIwMjAtMDEtMDQiLCJwYWlkVXBUbyI6IjIwMjEtMDEtMDMifSx7ImNvZGUiOiJSUzAiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUkMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUkQiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUEMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUk0iLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiV1MiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiREIiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiREMiLCJmYWxsYmFja0RhdGUiOiIyMDIwLTAxLTA0IiwicGFpZFVwVG8iOiIyMDIxLTAxLTAzIn0seyJjb2RlIjoiUlNVIiwiZmFsbGJhY2tEYXRlIjoiMjAyMC0wMS0wNCIsInBhaWRVcFRvIjoiMjAyMS0wMS0wMyJ9XSwiaGFzaCI6IjE2MDgwOTA5LzAiLCJncmFjZVBlcmlvZERheXMiOjcsImF1dG9Qcm9sb25nYXRlZCI6ZmFsc2UsImlzQXV0b1Byb2xvbmdhdGVkIjpmYWxzZX0=-I7c5mu4hUCMxcldrwZEJMaT+qkrzrF1bjJi0i5QHcrRxk2LO0jqzUe2fBOUR4L+x+7n6kCwAoBBODm9wXst8dWLXdq179EtjU3rfJENr1wXGgtef//FNow+Id5iRufJ4W+p+3s5959GSFibl35YtbELELuCUH2IbCRly0PUBjitgA0r2y+9jV5YD/dmrd/p4C87MccC74NxtQfRdeUEGx87vnhsqTFH/sP4C2VljSo/F/Ft9JqsSlGfwSKjzU8BreYt1QleosdMnMK7a+fkfxh7n5zg4DskdVlNbfe6jvYgMVE16DMXd6F1Zhwq+lrmewJA2jPToc+H5304rcJfa9w==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxcQkq+zdxlR2mmRYBPzGbUNdMN6OaXiXzxIWtMEkrJMO/5oUfQJbLLuMSMK0QHFmaI37WShyxZcfRCidwXjot4zmNBKnlyHodDij/78TmVqFl8nOeD5+07B8VEaIu7c3E1N+e1doC6wht4I4+IEmtsPAdoaj5WCQVQbrI8KeT8M9VcBIWX7fD0fhexfg3ZRt0xqwMcXGNp3DdJHiO0rCdU+Itv7EmtnSVq9jBG1usMSFvMowR25mju2JcPFp1+I4ZI+FqgR8gyG8oiNDyNEoAbsR3lOpI7grUYSvkB/xVy/VoklPCK2h0f0GJxFjnye8NT1PAywoyl7RmiAVRE/EKwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQAF8uc+YJOHHwOFcPzmbjcxNDuGoOUIP+2h1R75Lecswb7ru2LWWSUMtXVKQzChLNPn/72W0k+oI056tgiwuG7M49LXp4zQVlQnFmWU1wwGvVhq5R63Rpjx1zjGUhcXgayu7+9zMUW596Lbomsg8qVve6euqsrFicYkIIuUu4zYPndJwfe0YkS5nY72SHnNdbPhEnN8wcB2Kz+OIG0lih3yz5EqFhld03bGp222ZQCIghCTVL6QBNadGsiN/lWLl4JdR3lJkZzlpFdiHijoVRdWeSWqM4y0t23c92HXKrgppoSV18XMxrWVdoSM3nuMHwxGhFyde05OdDtLpCv+jlWf5REAHHA201pAU6bJSZINyHDUTB+Beo28rRXSwSh3OUIvYwKNVeoBY+KwOJ7WnuTCUq1meE6GkKc4D/cXmgpOyW/1SmBz3XjVIi/zprZ0zf3qH5mkphtg6ksjKgKjmx1cXfZAAX6wcDBNaCL+Ortep1Dh8xDUbqbBVNBL4jbiL3i3xsfNiyJgaZ5sX7i8tmStEpLbPwvHcByuf59qJhV/bZOl8KqJBETCDJcY6O2aqhTUy+9x93ThKs1GKrRPePrWPluud7ttlgtRveit/pcBrnQcXOl1rHq7ByB8CFAxNotRUYL9IF5n3wJOgkPojMy6jetQA5Ogc8Sm7RG6vg1yow==

		A82DEE284F-eyJsaWNlbnNlSWQiOiJBODJERUUyODRGIiwibGljZW5zZWVOYW1lIjoiaHR0cHM6Ly96aGlsZS5pbyIsImFzc2lnbmVlTmFtZSI6IiIsImFzc2lnbmVlRW1haWwiOiIiLCJsaWNlbnNlUmVzdHJpY3Rpb24iOiJVbmxpbWl0ZWQgbGljZW5zZSB0aWxsIGVuZCBvZiB0aGUgY2VudHVyeS4iLCJjaGVja0NvbmN1cnJlbnRVc2UiOmZhbHNlLCJwcm9kdWN0cyI6W3siY29kZSI6IklJIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlMwIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiV1MiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJSRCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiREMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJEQiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlJNIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiRE0iLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJBQyIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkRQTiIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IkdPIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUFMiLCJwYWlkVXBUbyI6IjIwODktMDctMDcifSx7ImNvZGUiOiJDTCIsInBhaWRVcFRvIjoiMjA4OS0wNy0wNyJ9LHsiY29kZSI6IlBDIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In0seyJjb2RlIjoiUlNVIiwicGFpZFVwVG8iOiIyMDg5LTA3LTA3In1dLCJoYXNoIjoiODkwNzA3MC8wIiwiZ3JhY2VQZXJpb2REYXlzIjowLCJhdXRvUHJvbG9uZ2F0ZWQiOmZhbHNlLCJpc0F1dG9Qcm9sb25nYXRlZCI6ZmFsc2V9-5epo90Xs7KIIBb8ckoxnB/AZQ8Ev7rFrNqwFhBAsQYsQyhvqf1FcYdmlecFWJBHSWZU9b41kvsN4bwAHT5PiznOTmfvGv1MuOzMO0VOXZlc+edepemgpt+t3GUHvfGtzWFYeKeyCk+CLA9BqUzHRTgl2uBoIMNqh5izlDmejIwUHLl39QOyzHiTYNehnVN7GW5+QUeimTr/koVUgK8xofu59Tv8rcdiwIXwTo71LcU2z2P+T3R81fwKkt34evy7kRch4NIQUQUno//Pl3V0rInm3B2oFq9YBygPUdBUbdH/KHROyohZRD8SaZJO6kUT0BNvtDPKF4mCT1saWM38jkw==-MIIElTCCAn2gAwIBAgIBCTANBgkqhkiG9w0BAQsFADAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBMB4XDTE4MTEwMTEyMjk0NloXDTIwMTEwMjEyMjk0NlowaDELMAkGA1UEBhMCQ1oxDjAMBgNVBAgMBU51c2xlMQ8wDQYDVQQHDAZQcmFndWUxGTAXBgNVBAoMEEpldEJyYWlucyBzLnIuby4xHTAbBgNVBAMMFHByb2QzeS1mcm9tLTIwMTgxMTAxMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA5ndaik1GD0nyTdqkZgURQZGW+RGxCdBITPXIwpjhhaD0SXGa4XSZBEBoiPdY6XV6pOfUJeyfi9dXsY4MmT0D+sKoST3rSw96xaf9FXPvOjn4prMTdj3Ji3CyQrGWeQU2nzYqFrp1QYNLAbaViHRKuJrYHI6GCvqCbJe0LQ8qqUiVMA9wG/PQwScpNmTF9Kp2Iej+Z5OUxF33zzm+vg/nYV31HLF7fJUAplI/1nM+ZG8K+AXWgYKChtknl3sW9PCQa3a3imPL9GVToUNxc0wcuTil8mqveWcSQCHYxsIaUajWLpFzoO2AhK4mfYBSStAqEjoXRTuj17mo8Q6M2SHOcwIDAQABo4GZMIGWMAkGA1UdEwQCMAAwHQYDVR0OBBYEFGEpG9oZGcfLMGNBkY7SgHiMGgTcMEgGA1UdIwRBMD+AFKOetkhnQhI2Qb1t4Lm0oFKLl/GzoRykGjAYMRYwFAYDVQQDDA1KZXRQcm9maWxlIENBggkA0myxg7KDeeEwEwYDVR0lBAwwCgYIKwYBBQUHAwEwCwYDVR0PBAQDAgWgMA0GCSqGSIb3DQEBCwUAA4ICAQBonMu8oa3vmNAa4RQP8gPGlX3SQaA3WCRUAj6Zrlk8AesKV1YSkh5D2l+yUk6njysgzfr1bIR5xF8eup5xXc4/G7NtVYRSMvrd6rfQcHOyK5UFJLm+8utmyMIDrZOzLQuTsT8NxFpbCVCfV5wNRu4rChrCuArYVGaKbmp9ymkw1PU6+HoO5i2wU3ikTmRv8IRjrlSStyNzXpnPTwt7bja19ousk56r40SmlmC04GdDHErr0ei2UbjUua5kw71Qn9g02tL9fERI2sSRjQrvPbn9INwRWl5+k05mlKekbtbu2ev2woJFZK4WEXAd/GaAdeZZdumv8T2idDFL7cAirJwcrbfpawPeXr52oKTPnXfi0l5+g9Gnt/wfiXCrPElX6ycTR6iL3GC2VR4jTz6YatT4Ntz59/THOT7NJQhr6AyLkhhJCdkzE2cob/KouVp4ivV7Q3Fc6HX7eepHAAF/DpxwgOrg9smX6coXLgfp0b1RU2u/tUNID04rpNxTMueTtrT8WSskqvaJd3RH8r7cnRj6Y2hltkja82HlpDURDxDTRvv+krbwMr26SB/40BjpMUrDRCeKuiBahC0DCoU/4+ze1l94wVUhdkCfL0GpJrMSCDEK+XEurU18Hb7WT+ThXbkdl6VpFdHsRvqAnhR2g4b+Qzgidmuky5NUZVfEaZqV/g==

	# Spring源码阅读：

		https://github.com/seaswalker/spring-analysis

			spring-core					// done 2020-2-6 16:19:33
			spring-aop					// done 2020-2-7 16:19:41
			spring-context				// done 2020-2-7 17:14:33
			spring-task					// done 2020-2-8 15:00:45

				定时器：

					用法：以XML作为示例，基于注解的也是一样的。
						xml：
							<task:scheduler id="scheduler" pool-size="3" />
							<bean id="task" class="task.Task"/>
							<task:scheduled-tasks scheduler="scheduler">
							    <task:scheduled ref="task" method="print" cron="0/5 * * * * ?"/>
							</task:scheduled-tasks>

						java:
							public class Task {
							    public void print() {
							        System.out.println("print执行");
							    }
							}

					解析：		

						注册：
							org.springframework.scheduling.config.TaskNamespaceHandler
								@Override
								public void init() {
								    this.registerBeanDefinitionParser("annotation-driven", new AnnotationDrivenBeanDefinitionParser());
								    this.registerBeanDefinitionParser("executor", new ExecutorBeanDefinitionParser());
								    this.registerBeanDefinitionParser("scheduled-tasks", new ScheduledTasksBeanDefinitionParser());
								    this.registerBeanDefinitionParser("scheduler", new SchedulerBeanDefinitionParser());
								}

						scheduler:
							SchedulerBeanDefinitionParser

						scheduler-tasks:
							ScheduledTasksBeanDefinitionParser

					调度执行：

						ContextLifecycleScheduledTaskRegistrar

						scheduler初始化:
							TaskScheduler 				// 同步执行
							ConcurrentTaskExecutor 		// 异步执行

						任务调度 ：
							org.springframework.scheduling.config.ScheduledTaskRegistrar#scheduleTriggerTask	
							org.springframework.scheduling.config.ScheduledTaskRegistrar#scheduleCronTask
							org.springframework.scheduling.config.ScheduledTaskRegistrar#scheduleFixedRateTask
							org.springframework.scheduling.config.ScheduledTaskRegistrar#scheduleFixedDelayTask

						Trigger：

						Cron解析：
							CronTask
							CronTrigger
							CronSequenceGenerator

						调度：
							ReschedulingRunnable.schedule

				异步执行：
				
					xml:
						<task:executor id="executor" pool-size="3"/>
						<task:annotation-driven executor="executor"/>			

					java:
						@Async("executor")
						public void print() {
						    System.out.println("print执行");
						}	

			spring-transaction			// 初略看了 2020-2-8 15:20:16 done 2020-2-9 16:17:27

				配置：

					<!-- 数据源以Sping自带为例，每次请求均返回一个新的连接 -->
					<bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">
					    <property name="driverClassName" value="${jdbc.driverClassName}" />
					    <property name="url" value="${jdbc.url}" />
					    <property name="username" value="${jdbc.username}" />
					    <property name="password" value="${jdbc.password}" />
					</bean>
					<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
					    <property name="dataSource" ref="dataSource"/>
					</bean>
					<tx:annotation-driven transaction-manager="transactionManager"/>

				解析：
					
					TxNamespaceHandler
						@Override
						public void init() {
						    registerBeanDefinitionParser("advice", new TxAdviceBeanDefinitionParser());
						    registerBeanDefinitionParser("annotation-driven", 
						        new AnnotationDrivenBeanDefinitionParser());
						    registerBeanDefinitionParser("jta-transaction-manager", new JtaTransactionManagerBeanDefinitionParser());
						}	

					AnnotationDrivenBeanDefinitionParser.parse()
					
					TransactionalEventListener

					AnnotationTransactionAttributeSource: 解析@Transactional注解的相关属性	

				运行：

					JdkDynamicAopProxy.invoke

					事务拦截器：TransactionInterceptor

					事务管理器：DataSourceTransactionManager等等

					事务开启：TransactionAspectSupport.createTransactionIfNecessary

					是否已存在事务：TransactionSynchronizationManager.doGetResource

						是否存在事务指的是在当前线程、当前数据源(DataSource)中是否存在处于活动状态的事务。

					事务已存在：

						如果检测到已存在事务，那么就要考虑事务的传播特性(行为)：

							AbstractPlatformTransactionManager.handleExistingTransaction

						事务挂起：

							所谓的事务挂起其实就是一个移除当前线程、数据源活动事务对象的过程。

					事务创建：DataSourceTransactionManager.doBegin
					
						Spring事务的开启实际上是将数据库的自动提交设为false。

					事务提交 & 回滚：
						
						其实就是对jdbc相应方法的封装，不再展开。				
				
				总结：		

					事务的本质其实是对数据库自动提交的关闭与开启，传播特性是Spring提出、实现、控制的概念，而隔离级别是对数据库实现的封装。

			spring-mvc			// 初略阅读 2020-2-9 16:39:21	done 2020-2-10 11:54:45

				核心：DispatcherServlet

				初始化：HttpServletBean.init

				容器创建：FrameworkServlet.createWebApplicationContext

				配置解析：MvcNamespaceHandler

				MVC初始化：DispatcherServlet.initStrategies

				HandlerMapping初始化：

					RequestMappingHandlerMapping

					DefaultAnnotationHandlerMapping

					BeanNameUrlHandlerMapping

				HandlerAdapter初始化：

					RequestMappingHandlerAdapter

				请求响应：FrameworkServlet.service	

					请求分发: DispatcherServlet.doDispatch

						处理器查找: DispatcherServlet.getHandler

						适配器查找: DispatcherServlet.getHandlerAdapter

					请求处理: RequestMappingHandlerAdapter.handleInternal

						Session同步: 

						参数解析: RequestParamMethodArgumentResolver

							Model解析: ModelMethodProcessor

						返回值解析: ViewNameMethodReturnValueHandler

						视图渲染: DispatcherServlet.processDispatchResult

							渲染: DispatcherServlet.render

					参数绑定: DataBinder
					
					参数校验: ModelAttributeMethodProcessor.resolveArgument  DataBinder.validate	


			guava-cache			// 初略阅读 2020-2-9 16:39:27

2020-2-12 10:58:41

	# spring framework 5 learn, step by step, include this:

		** reference-guide：			

		** demo/test:

		** source-code:

			Spring代码风格（Code Style），地址: https://github.com/spring-projects/spring-framework/wiki/Code-Style

				有几点值得关注的：

					## 导入语句 Import statements：

						The import statements are structured as follow:

							import java.* 
							blank line
							import javax.* 
							blank line
							import all other imports
							blank line
							import org.springframework.* 
							blank line
							import static all other imports

						静态导入不应该在生产代码中使用，应该用在测试代码中，比如：import static org.assertj.core.api.Assertions.assertThat;

						通配符导入，比如：import java.util.*; or import static org.assertj.core.api.Assertions.*，是禁止的，包括测试代码中。

					## Java源文件结构 Java source file organization：

						1. static fields
						2. normal fields
						3. constructors
						4. (private) methods called from constructors
						5. static factory methods
						6. JavaBean properties (i.e., getters and setters)
						7. method implementations coming from interfaces
						8. private or protected templates that get called from method implementations coming from interfaces 
						9. other methods
						10. equals, hashCode, and toString 

						private和protected方法应该紧跟在调用他们的方法的下方。比如：

							public interface Service {
								void init();
								void service();
								void post();
							}

							public class ServiceImple implements Service {

								@Override
								public void init() {
									aaa();
								}

								private void aaa() {};

								@Override
								public void service() {
									bbb();
								}

								private void bbb() {};

								@Override
								public void post() {
									ccc();
								}

								private void ccc() {};
							}

					## Formatting		

						### 花括号 Braces：

							Block-like constructs: K&R style

							Braces mostly follow the Kernighan and Ritchie style (a.k.a., "Egyptian brackets") for nonempty blocks and block-like constructs:
								No line break before the opening brace but prefixed by a single space
								Line break after the opening brace
								Line break before the closing brace
								Line break after the closing brace if that brace terminates a statement or the body of a method, constructor, or named class
								Line break before else, catch and finally statements 

							Example:

								return new MyClass() {
									@Override 
									public void method() {
										if (condition()) {
											something();
										}
										else {
											try {
												alternative();
											} 
											catch (ProblemException ex) {
												recover();
											}
											finally {
												closeIO();
											}
										}
									}
								};

							tips:

								第四点和我们平时推荐的不太一样。Spring推荐： else、catch、finallly语句之前换行。

						### 换行 Line wrapping		

							0-90： 推荐
							90-105: 可以接受
							105-120: 允许但不鼓励，应该尽可能避免
							> 120: 不允许

							推荐80字符左右，原因是为了各种文档/设备，包括在Github上、手机等上的格式兼容适配。

							还有，分隔符放在行尾，而不是下一行。比如：
							
									if (thisLengthyMethodCall(param1, param2) && anotherCheck() &&
									        yetAnotherCheck()) {

									    // ....
									}

						### 空行 Blank Line			

							两个空行 Add two blank lines before the following elements:
								static {} block
								Fields
								Constructors
								Inner classes

							一个空行：Add one blank line after a method signature that is multiline, i.e.

								@Override
								protected Object invoke(FooBarOperationContext context, 
								        AnotherSuperLongName name) {

								    // code here
								}

					##编码实践 Programming Practices			

						### Ternary Operator 三目运算符

							三目运算符要用圆括号括起来， i.e. return (foo != null ? foo : "default");

							而且非空判断 not null 要在前面。


						### Null Checks	

							Use the org.springframework.util.Assert.notNull static method to check that a method argument is not null.

							public void handle(Event event) {
							    Assert.notNull(event, "Event must not be null");
							    //...
							}

						### 通用工具类 Utility classes	

							一个只有static通用方法的类，类名必须以Utils结尾，必须有私有的构造方法，类修饰符需要用abstact。防止使用者尝试实例化。

								public abstract MyUtils {

								    private MyUtils() {
								        /* prevent instantiation */
								    }

								    // static utility methods
								}

						### 对象和方法引用 Field and method references		

							类中的对象引用时使用this.，类中的方法引用时禁止使用this.
							A field of a class should always be referenced using this. A method of class, however, should never be referenced using this.

					## Javadoc		

						In particular, please note:

							Use an imperative style (i.e. Return and not Returns) for the first sentence.

							// 描述和参数描述之前无需空行
							No blank lines between the description and the parameter descriptions.

							// 如果有多个段落，每个段落之前使用<p>标签
							If the description is defined with multiple paragraphs, start each of them with <p>.
							
							If a parameter description needs to be wrapped, do not indent subsequent lines (see parserContext).

						其他：
							
							** 有代码/null时，使用{@code}包起来。
							** 如果使用元素{@link}，使用全路径限定名，避免import导入。如：
								provides access to a {@link org.springframework.beans.factory.support.BeanDefinitionRegistry}

# 2020-2-13 15:22:32

	# spring framework reference + spring guide demo + spring source code 

		
2020-2-14 20:08:23

	# ClassPathXmlApplicationContext源码阅读，未完待续

2020-2-15 16:25:58

	# AbstractApplicationContext.refresh()执行流程，未完待续：

		@Override
		public void refresh() throws BeansException, IllegalStateException {
		    synchronized (this.startupShutdownMonitor) {
		        // Prepare this context for refreshing.
		        prepareRefresh();

		        // Tell the subclass to refresh the internal bean factory.  // done 2020-2-15 19:54:35
		        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

		        // Prepare the bean factory for use in this context.
		        prepareBeanFactory(beanFactory);

		        try {
		            // Allows post-processing of the bean factory in context subclasses.
		            postProcessBeanFactory(beanFactory);

		            // Invoke factory processors registered as beans in the context.
		            invokeBeanFactoryPostProcessors(beanFactory);

		            // Register bean processors that intercept bean creation.
		            registerBeanPostProcessors(beanFactory);

		            // Initialize message source for this context.
		            initMessageSource();

		            // Initialize event multicaster for this context.
		            initApplicationEventMulticaster();

		            // Initialize other special beans in specific context subclasses.
		            onRefresh();

		            // Check for listener beans and register them.
		            registerListeners();

		            // Instantiate all remaining (non-lazy-init) singletons.
		            finishBeanFactoryInitialization(beanFactory);

		            // Last step: publish corresponding event.
		            finishRefresh();
		        }

		        catch (BeansException ex) {
		            if (logger.isWarnEnabled()) {
		                logger.warn("Exception encountered during context initialization - " +
		                            "cancelling refresh attempt: " + ex);
		            }

		            // Destroy already created singletons to avoid dangling resources.
		            destroyBeans();

		            // Reset 'active' flag.
		            cancelRefresh(ex);

		            // Propagate exception to caller.
		            throw ex;
		        }

		        finally {
		            // Reset common introspection caches in Spring's core, since we
		            // might not ever need metadata for singleton beans anymore...
		            resetCommonCaches();
		        }
		    }
		}

2020-2-17 14:56:14

	# ContextPathXmlApplicationContext:

		org.springframework.context.support.AbstractApplicationContext#refresh	

			synchronized (this.startupShutdownMonitor) {

				
				// 刷新准备
				// Prepare this context for refreshing.
				prepareRefresh();

					设置启动时间-startupDate
					设置容器状态： 
						关闭状态-closed = false
						激活状态-active = true

					初始化占位符属性源
					initPropertySources();

					必输的属性校验
					getEnvironment().validateRequiredProperties();

					判断刷新前的应用监听器-earlyApplicationListeners是否为null
						如果是：
							保存刷新前的应用监听器： 
							this.earlyApplicationListeners = new LinkedHashSet<>(this.applicationListeners);
						否则	:
							重置应用监听器为刷新前的状态
							this.applicationListeners.clear();
							this.applicationListeners.addAll(this.earlyApplicationListeners);

					初始化需要提前的应用事件-earlyApplicationEvents
					this.earlyApplicationEvents = new LinkedHashSet<>();


				// 通知子类将要刷新内置的beanFactory
				// Tell the subclass to refresh the internal bean factory.
				ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

					// beanFactory的刷新操作，如果之前有beanFactory，则先关闭，然后初始化一个新的beanFactory，为context生命周期下一阶段使用
					refreshBeanFactory();

						判断是否已有beanFactory，如果有：
							摧毁beans
							关闭beanFactory

						新建beanFactory

						设置序列化编号

						设置beanFactory	
							是否允许Bean定义信息重写
							是否允许循环引用

						加载bean定义信息，xml实现：AbstractXmlApplicationContext#loadBeanDefinitions

							为指定的beanFactory创建Bean定义信息读取器

							设置环境信息environment = this.getEnvironment();
							设置资源加载器resourceLoader = this;
							设置实体解析器entityResolver = new ResourceEntityResolver(this)

							初始化bean定义信息读取器beanDefinitionReader

							加载bean定义信息
								根据配置资源configResources加载
								根据配置路径configLocations加载

					return getBeanFactory();


				// beanFactory使用前准备
				// Prepare the bean factory for use in this context.
				prepareBeanFactory()

					设置Bean类加载器beanClassLoader = 当前类加载器
					设置Bean表达式解析器beanExpressionResolver 
						= StandardBeanExpressionResolver[标准的Bean表达式解析器]
					添加属性编辑器的注册器propertyEditorRegistrars
						add ResourceEditorRegistrar[资源编辑器注册器]

					添加Bean后置处理器
						beanPostProcessors add ApplicationContextAwareProcessor[应用通知处理器]
					忽略接口依赖ignoredDependencyInterfaces 
						add EnvironmentAware[环境通知类]
						add EmbeddedValueResolverAware[内嵌的值处理器通知类]
						add ResourceLoaderAware[资源加载器通知类]
						add ApplicationEventPublisherAware[应用事件发布器通知类]
						add MessageSourceAware[消息源通知类]
						add ApplicationContextAware[应用上下文通知类]

					注册可解析的依赖resolvableDependencies
						put {BeanFactory.class， beanFactory}
						put {ResourceLoader.class.class， this}
						put {ApplicationEventPublisher.class， this}
						put {ApplicationContext.class， this}

					添加Bean后置处理器beanPostProcessors 
						add ApplicationListenerDetector[应用监听处理器]

					如果beanFactory包含loadTimeWeaver[加载时植入类]，如果有，
						Bean请求处理器beanPostProcessors 
							add LoadTimeWeaverAwareProcessor[加载时植入通知处理器]
						设置临时类加载器tempClassLoader 
							= ContextTypeMatchClassLoader[上下文类型匹配类加载器]

					注册默认的环境相关beans，包括：environment	, systemProperties, systemEnvironment


				try --------------------------------------------------------------	


					// 后置处理context子类中的beanFactory
					// Allows post-processing of the bean factory in context subclasses.
					postProcessBeanFactory	

						默认实现为空，子类可覆盖


					// 调用context中 已注册为beans的 beanFactory后置处理器
					// Invoke factory processors registered as beans in the context.
					invokeBeanFactoryPostProcessors

						调用BeanFactory后置处理器
							判断beanFactory是否是Bean定义信息注册类的子类
								如果是：
									优先调用Bean定义注册的后置处理器BeanDefinitionRegistryPostProcessor，如果有
										按照实现的接口优先级顺序遍历调用（PriorityOrdered > Ordered > 其他）
									再调用BeanFactoryPostProcessor
										按照顺序遍历调用（registryProcessors > regularPostProcessors）
								否则：
									遍历调用指定的后置处理器beanFactoryPostProcessors

							调用其他还未调用过的普通beans的beanFactory后置处理器：
								按照实现的接口优先级顺序遍历调用（PriorityOrdered > Ordered > 其他）

							至此，所有后置处理器均已调用完成！！！！！

						如果 beanFactory中有loadTimeWeaver[加载时植入器] && tempClassLoader[临时类加载器]为null：
							Bean请求处理器beanPostProcessors 
						    	add LoadTimeWeaverAwareProcessor[加载时植入通知处理器]
							设置临时类加载器tempClassLoader 
						    	= ContextTypeMatchClassLoader[上下文类型匹配类加载器]


					// 注册拦截bean创建的bean后置处理器
					// Register bean processors that intercept bean creation.				
					registerBeanPostProcessors

						org.springframework.context.support.PostProcessorRegistrationDelegate#registerBeanPostProcessors(
							ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) 

								从beanFactory中获取BeanPostProcessor类型的beans

								按顺序添加bean后置处理器： [beanPostProcessors add ...]
									-- BeanPostProcessorChecker[BeanPostProcessor检查器]
									-- 实现了PriorityOrdered的BeanPostProcessors
									-- 实现了Ordered的BeanPostProcessors
									-- 其他普通的BeanPostProcessors
									-- 内置的BeanPostProcessors
									-- 应用监听器探测器[ApplicationListenerDetector]


					// 初始化消息源
					// Initialize message source for this context.
					initMessageSource

						判断beanFacory中是否有名称为'messageSource'的bean：

							如果有：
								如果父容器不为空，且此messageSource可继承
									如果父容器的数据源为空
										设置父容器消息源
							如果没有：
								设置父容器消息源[dms = new DelegatingMessageSource()]
								设置此容器消息源[this.messageSource = dms]
								注册单例bean，名称为[messageSource]，内容为[this.messageSource]


					// 初始化事件广播器
					// Initialize event multicaster for this context.
					initApplicationEventMulticaster

						判断beanFacory中是否有名称为'applicationEventMulticaster'的bean：				

							如果有：
								获取并设置为当前的applicationEventMulticaster

							如果没有：
								新建并设置为当前的applicationEventMulticaster
									this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
								注册单例bean，名称为[applicationEventMulticaster]，内容为[this.applicationEventMulticaster]


					// 初始化容器子类中的特殊bean			
					// Initialize other special beans in specific context subclasses.			
					onRefresh

						模板方法，默认为空，可被子类重写。


					// 注册监听器
					// Check for listener beans and register them.
					registerListeners

						注册容器中的静态特殊监听器

						从beanFactory中获取ApplicationListener类的beans，并注册

						提前发布 需要提前发布的 应用事件[监听器提早执行]


					// 初始化所有剩余的单例bean
					// Instantiate all remaining (non-lazy-init) singletons.
					finishBeanFactoryInitialization

						初始化conversionService
						
						如果没有内置的取值解析器embeddedValueResolvers，则注册一个默认的

						提前初始化加载时植入通知器LoadTimeWeaverAware，以便进行提前处理

						停止使用类型匹配的临时类加载器: this.tempClassLoader = null

						缓存所有的bean定义元数据，不再修改: 
							this.configurationFrozen = true; 
							this.frozenBeanDefinitionNames = StringUtils.toStringArray(this.beanDefinitionNames);

						初始化其他的单例bean（非懒加载的）


					// 最后一步，发布相关事件
					// Last step: publish corresponding event.
					finishRefresh	

						// 清除context级别的资源缓存
						// Clear context-level resource caches (such as ASM metadata from scanning).
						clearResourceCaches();

						// 初始化context的生命周期处理器lifecycleProcessor
						// Initialize lifecycle processor for this context.
						initLifecycleProcessor();

						// 通知生命周期处理器refresh事件
						// Propagate refresh to lifecycle processor first.
						getLifecycleProcessor().onRefresh();

						// 发布最终的事件
						// Publish the final event.
						publishEvent(new ContextRefreshedEvent(this));

						// 如果可以，参与活动的Beans视图LiveBeansView
						// Participate in LiveBeansView MBean, if active.
						LiveBeansView.registerApplicationContext(this);


				catch BeansException ex -----------------------------------------------------


					// 清除已经创建的单例bean
					// Destroy already created singletons to avoid dangling resources.
					destroyBeans();


					// 容器激活标识active设置为false
					// Reset 'active' flag.
					cancelRefresh(ex);


					// 抛出异常
					// Propagate exception to caller.
					throw ex;


				finally -----------------------------------------------------


					重置通用缓存信息
					// Reset common introspection caches in Spring's core, since we
					// might not ever need metadata for singleton beans anymore...
					resetCommonCaches();

						// 反射工具类缓存清除
						ReflectionUtils.clearCache();

						// 注解工具类缓存清除
						AnnotationUtils.clearCache();

						// 类型解析相关缓存清除
						ResolvableType.clearCache();

						// 缓存的自省结果清除
						CachedIntrospectionResults.clearClassLoader(getClassLoader());

				-------------------------------------------------------------
				至此，容器初始化refresh()执行完成。。。。。
			













							

































	 


		

























		  	

	









			 	  



