Spring FrameWork：

	** IOC: 控制反转 Inversion of Control

		通俗的说就是我们不用自己创建实例对象，这些都交给Spring的bean工厂帮我们创建管理。这也是Spring的核心思想，通过面向接口编程的方式来是实现对业务组件的动态依赖。这就意味着IOC是Spring针对解决程序耦合而存在的。在实际应用中，Spring通过配置文件（xml或者properties）指定需要实例化的java类（类名的完整字符串），包括这些java类的一组初始化值，通过加载读取配置文件，用Spring提供的方法（getBean()）就可以获取到我们想要的根据指定配置进行初始化的实例对象。

		实现方式：

			1.属性注入，或叫做set方法注入；
			2.构造方法注入；
			3.注解注入，可能因为方便的原因，这种方式免去了臃肿的配置，所以比较常用。

		IOC与DI的区别：
			
			IOC即控制反转，一种将控制权转移的设计模式，由传统的程序控制转移到容器控制；
			DI即依赖注入，将相互依赖的对象分离，在Spring的配置（注解）中描述它们之间的依赖关系，这些依赖关系也只在使用时才被建立。
			AOP即面向切面，一种编程思想，OOP的延续。将系统中非核心的业务提取出来，进行单独处理。
			Spring的AOP和IOC都是为了解决代码的耦合度的实际应用，使得代码的重用度变高，便于维护。但这些都不是Spring中特有的，我们可以说Spring将它们应用的更灵活。	

	** AOP:

		将程序功能中的频繁出现或者与主业务逻辑代码相关度不高的代码抽离出来，通过切面编程的方式在想要调用的时候引入调用的思想。而这种思想并不是只限于Spring和java，AOP（面向切面）和OOP（面向对象）一样都是一种编程思想，这种思想的实现机制在Spring中便是应用了java的动态代理和java的反射。在实际编程中，我们通常会遇到一些交叉业务逻辑（比如：日志，事务，安全等等），这是我们就可以封装一个封面，然后注入到目标对象（具体的业务逻辑）中去。ps：很多方法都会抛出异常信息，这是我们就可以写一个拦截器，在这个类中实现记录错误日志的功能，再在Spring的xml配置文件中配置一个对这些要记录日志的方法的AOP拦截器，在这个方法执行后调用这个拦截器来记录日志。这样就不用每次抛出异常都要手动的去单独处理记录，提高了程序的内聚性。这种在调用某个方法之前/后想要自动执行一系列自定义操作的就是AOP思想。

	** Component与Service注解的区别：

		@Component, @Service, @Controller, @Repository是spring注解，注解后可以被spring框架所扫描并注入到spring容器来进行管理 
		@Component是通用注解，其他三个注解是这个注解的拓展，并且具有了特定的功能 
		@Repository注解在持久层中，具有将数据库操作抛出的原生异常翻译转化为spring的持久层异常的功能。 
		@Controller层是spring-mvc的注解，具有将请求进行转发，重定向的功能。 
		@Service层是业务逻辑层注解，这个注解只是标注该类处于业务逻辑层。 

	** 事务

		四大特性：

			原子性(Atomicity)：事务是数据库的逻辑工作单位，它对数据库的修改要么全部执行，要么全部不执行。 
			一致性(Consistemcy)：事务前后，数据库的状态都满足所有的完整性约束。 
			隔离性(Isolation)：并发执行的N个事务是隔离的，一个不影响一个，一个事务在没有commit之前，被修改的数据不可能被其他事务看到（通过设置数据库的隔离级别）。 
			持久性(Durability)：持久性意味着当系统或介质发生故障时，确保已提交事务的更新不能丢失。持久性主要在于DBMS的恢复性能。
	
		传播机制：

			PROPAGATION_REQUIRED
				表示当前方法必须运行在事务中。如果当前事务存在，方法将会在该事务中运行。否则，会启动一个新的事务

			PROPAGATION_SUPPORTS
				表示当前方法不需要事务上下文，但是如果存在当前事务的话，那么该方法会在这个事务中运行

			PROPAGATION_MANDATORY
				表示该方法必须在事务中运行，如果当前事务不存在，则会抛出一个异常

			PROPAGATION_REQUIRED_NEW
				表示当前方法必须运行在它自己的事务中。一个新的事务将被启动。如果存在当前事务，在该方法执行期间，当前事务会被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager

			PROPAGATION_NOT_SUPPORTED
				表示该方法不应该运行在事务中。如果存在当前事务，在该方法运行期间，当前事务将被挂起。如果使用JTATransactionManager的话，则需要访问TransactionManager

			PROPAGATION_NEVER
				表示当前方法不应该运行在事务上下文中。如果当前正有一个事务在运行，则会抛出异常

			PROPAGATION_NESTED
				表示如果当前已经存在一个事务，那么该方法将会在嵌套事务中运行。嵌套的事务可以独立于当前事务进行单独地提交或回滚。如果当前事务不存在，那么其行为与PROPAGATION_REQUIRED一样。注意各厂商对这种传播行为的支持是有所差异的。可以参考资源管理器的文档来确认它们是否支持嵌套事务

		隔离级别：

			ISOLATION_DEFAULT
				使用后端数据库默认的隔离级别，Oracle默认: ISOLATION_READ_COMMITTED, MySQL默认: ISOLATION_REPEATABLE_READ

			ISOLATION_READ_UNCOMMITTED
				最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读

			ISOLATION_READ_COMMITTED
				允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生

			ISOLATION_REPEATABLE_READ
				对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生

			ISOLATION_SERIALIZABLE
				最高的隔离级别，完全服从ACID的隔离级别，确保阻止脏读、不可重复读以及幻读，也是最慢的事务隔离级别，因为它通常是通过完全锁定事务相关的数据库表来实现的

		tips：
		
			脏读： 读取未提交数据（无效数据读出。一个事务读取另外一个事务还没有提交的数据叫脏读。）

				e.g: 事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。

			幻读： 前后多次读取，数据总量不一致	（新增或者删除）

			不可重复读： 前后多次读取，数据内容不一致（修改）
