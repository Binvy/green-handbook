Hibernate Validator 6.0.17.Final Reference Guide

	Table of Contents
		Preface

			1. Getting started 
				1.1. Project set up 
					1.1.1. Unified EL
					1.1.2. CDI
					1.1.3. Running with a security manager
					1.1.4. Updating Hibernate Validator in WildFly
					1.1.5. Running on Java 9
				1.2. Applying constraints
				1.3. Validating constraints
				1.4. Where to go next?

			2. Declaring and validating bean constraints 
				2.1. Declaring bean constraints 
					2.1.1. Field-level constraints
					2.1.2. Property-level constraints
					2.1.3. Container element constraints
					2.1.4. Class-level constraints
					2.1.5. Constraint inheritance
					2.1.6. Object graphs
				2.2. Validating bean constraints 
					2.2.1. Obtaining a Validator instance
					2.2.2. Validator methods
					2.2.3. ConstraintViolation
				2.3. Built-in constraints 
					2.3.1. Bean Validation constraints
					2.3.2. Additional constraints

			3. Declaring and validating method constraints 
				3.1. Declaring method constraints 
					3.1.1. Parameter constraints
					3.1.2. Return value constraints
					3.1.3. Cascaded validation
					3.1.4. Method constraints in inheritance hierarchies
				3.2. Validating method constraints 
					3.2.1. Obtaining an ExecutableValidator instance
					3.2.2. ExecutableValidator methods
					3.2.3. ConstraintViolation methods for method validation
				3.3. Built-in method constraints

			4. Interpolating constraint error messages 
				4.1. Default message interpolation 
					4.1.1. Special characters
					4.1.2. Interpolation with message expressions
					4.1.3. Examples
				4.2. Custom message interpolation 
					4.2.1. ResourceBundleLocator

			5. Grouping constraints 
				5.1. Requesting groups
				5.2. Group inheritance
				5.3. Defining group sequences
				5.4. Redefining the default group sequence 
					5.4.1. @GroupSequence
					5.4.2. @GroupSequenceProvider
				5.5. Group conversion

			6. Creating custom constraints 
				6.1. Creating a simple constraint 
					6.1.1. The constraint annotation
					6.1.2. The constraint validator
					6.1.3. The error message
					6.1.4. Using the constraint
				6.2. Class-level constraints 
					6.2.1. Custom property paths
				6.3. Cross-parameter constraints
				6.4. Constraint composition

			7. Value extraction 
				7.1. Built-in value extractors
				7.2. Implementing a ValueExtractor
				7.3. Non generic containers
				7.4. JavaFX value extractors
				7.5. Registering a ValueExtractor
				7.6. Resolution algorithms

			8. Configuring via XML 
				8.1. Configuring the validator factory in validation.xml
				8.2. Mapping constraints via constraint-mappings

			9. Bootstrapping 
				9.1. Retrieving ValidatorFactory and Validator 
					9.1.1. ValidationProviderResolver
				9.2. Configuring a ValidatorFactory 
					9.2.1. MessageInterpolator
					9.2.2. TraversableResolver
					9.2.3. ConstraintValidatorFactory
					9.2.4. ParameterNameProvider
					9.2.5. ClockProvider and temporal validation tolerance
					9.2.6. Registering ValueExtractors
					9.2.7. Adding mapping streams
					9.2.8. Provider-specific settings
					9.2.9. Configuring the ScriptEvaluatorFactory
				9.3. Configuring a Validator

			10. Using constraint metadata 
				10.1. BeanDescriptor
				10.2. PropertyDescriptor
				10.3. MethodDescriptor and ConstructorDescriptor
				10.4. ElementDescriptor
				10.5. ContainerDescriptor and ContainerElementTypeDescriptor
				10.6. GroupConversionDescriptor
				10.7. ConstraintDescriptor

			11. Integrating with other frameworks 
				11.1. ORM integration 
					11.1.1. Database schema-level validation
					11.1.2. Hibernate ORM event-based validation
					11.1.3. JPA
				11.2. JSF & Seam
				11.3. CDI 
					11.3.1. Dependency injection
					11.3.2. Method validation
				11.4. Java EE
				11.5. JavaFX

			12. Hibernate Validator Specifics 
				12.1. Public API
				12.2. Fail fast mode
				12.3. Relaxation of requirements for method validation in class hierarchies
				12.4. Programmatic constraint definition and declaration
				12.5. Applying programmatic constraint declarations to the default validator factory
				12.6. Advanced constraint composition features 
					12.6.1. Validation target specification for purely composed constraints
					12.6.2. Boolean composition of constraints
				12.7. Extensions of the Path API
				12.8. Dynamic payload as part of ConstraintViolation
				12.9. ParameterMessageInterpolator
				12.10. ResourceBundleLocator
				12.11. Custom contexts 
					12.11.1. HibernateConstraintValidatorContext
					12.11.2. HibernateMessageInterpolatorContext
				12.12. Paranamer based ParameterNameProvider
				12.13. Providing constraint definitions 
					12.13.1. Constraint definitions via ServiceLoader
					12.13.2. Adding constraint definitions programmatically
				12.14. Customizing class-loading

			13. Annotation Processor 
				13.1. Prerequisites
				13.2. Features
				13.3. Options
				13.4. Using the Annotation Processor 
					13.4.1. Command line builds
					13.4.2. IDE builds
				13.5. Known issues

			14. Further reading
	
1. Getting started

	1.1 Project set up 

		<dependency>
		    <groupId>org.hibernate.validator</groupId>
		    <artifactId>hibernate-validator</artifactId>
		    <version>6.0.17.Final</version>
		</dependency>

		dependecy: javax.validation:validation-api:2.0.1.Final

		1.1.1 Unified EL

			<dependency>
			    <groupId>org.glassfish</groupId>
			    <artifactId>javax.el</artifactId>
			    <version>3.0.1-b09</version>
			</dependency>

		1.1.2 CDI
			
			<dependency>
			    <groupId>org.hibernate.validator</groupId>
			    <artifactId>hibernate-validator-cdi</artifactId>
			    <version>6.0.17.Final</version>
			</dependency>	

		1.1.3 Running with security manager	

			grant codeBase "file:path/to/hibernate-validator-6.0.17.Final.jar" {
			    permission java.lang.reflect.ReflectPermission "suppressAccessChecks";
			    permission java.lang.RuntimePermission "accessDeclaredMembers";
			    permission java.lang.RuntimePermission "setContextClassLoader";

			    permission org.hibernate.validator.HibernateValidatorPermission "accessPrivateMembers";

			    // Only needed when working with XML descriptors (validation.xml or XML constraint mappings)
			    permission java.util.PropertyPermission "mapAnyUriToUri", "read";
			};

			grant codeBase "file:path/to/validation-api-2.0.1.Final.jar" {
			    permission java.io.FilePermission "path/to/hibernate-validator-6.0.17.Final.jar", "read";
			};

			grant codeBase "file:path/to/jboss-logging-3.3.2.Final.jar" {
			    permission java.util.PropertyPermission "org.jboss.logging.provider", "read";
			    permission java.util.PropertyPermission "org.jboss.logging.locale", "read";
			};

			grant codeBase "file:path/to/classmate-1.3.4.jar" {
			    permission java.lang.RuntimePermission "accessDeclaredMembers";
			};

			grant codeBase "file:path/to/validation-caller-x.y.z.jar" {
			    permission org.hibernate.validator.HibernateValidatorPermission "accessPrivateMembers";
			};

		1.1.4 Updating Hibernate Validator in Wildfly
		
			Maven dependency for WildFly 16.0.0.Final patch file

				<dependency>
				    <groupId>org.hibernate.validator</groupId>
				    <artifactId>hibernate-validator-modules</artifactId>
				    <version>6.0.17.Final</version>
				    <classifier>wildfly-16.0.0.Final-patch</classifier>
				    <type>zip</type>
				</dependency>	

			Maven dependency for WildFly 17.0.0.Beta1 patch file
			
				<dependency>
				    <groupId>org.hibernate.validator</groupId>
				    <artifactId>hibernate-validator-modules</artifactId>
				    <version>6.0.17.Final</version>
				    <classifier>wildfly-17.0.0.Beta1-patch</classifier>
				    <type>zip</type>
				</dependency>	

			Applying the WildFly patch
				
				$JBOSS_HOME/bin/jboss-cli.sh patch apply hibernate-validator-modules-6.0.17.Final-wildfly-16.0.0.Final-patch.zip

			Rolling back the WildFly patch
			
				$JBOSS_HOME/bin/jboss-cli.sh patch rollback --reset-configuration=true

		1.1.5 Running in Java9
		
	1.2 Applying constraints

		import javax.validation.constraints.Min;
		import javax.validation.constraints.NotNull;
		import javax.validation.constraints.Size;

		public class Car {

		    @NotNull
		    private String manufacturer;

		    @NotNull
		    @Size(min = 2, max = 14)
		    private String licensePlate;

		    @Min(2)
		    private int seatCount;

		    public Car(String manufacturer, String licencePlate, int seatCount) {
		        this.manufacturer = manufacturer;
		        this.licensePlate = licencePlate;
		        this.seatCount = seatCount;
		    }

		    //getters and setters ...
		}	

	1.3 Validating constraints
	
		import java.util.Set;
		import javax.validation.ConstraintViolation;
		import javax.validation.Validation;
		import javax.validation.Validator;
		import javax.validation.ValidatorFactory;

		import org.junit.BeforeClass;
		import org.junit.Test;

		import static org.junit.Assert.assertEquals;

		public class CarTest {

		    private static Validator validator;

		    @BeforeClass
		    public static void setUpValidator() {
		        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
		        validator = factory.getValidator();
		    }

		    @Test
		    public void manufacturerIsNull() {
		        Car car = new Car( null, "DD-AB-123", 4 );

		        Set<ConstraintViolation<Car>> constraintViolations =
		                validator.validate( car );

		        assertEquals( 1, constraintViolations.size() );
		        assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );
		    }

		    @Test
		    public void licensePlateTooShort() {
		        Car car = new Car( "Morris", "D", 4 );

		        Set<ConstraintViolation<Car>> constraintViolations =
		                validator.validate( car );

		        assertEquals( 1, constraintViolations.size() );
		        assertEquals(
		                "size must be between 2 and 14",
		                constraintViolations.iterator().next().getMessage()
		        );
		    }

		    @Test
		    public void seatCountTooLow() {
		        Car car = new Car( "Morris", "DD-AB-123", 1 );

		        Set<ConstraintViolation<Car>> constraintViolations =
		                validator.validate( car );

		        assertEquals( 1, constraintViolations.size() );
		        assertEquals(
		                "must be greater than or equal to 2",
		                constraintViolations.iterator().next().getMessage()
		        );
		    }

		    @Test
		    public void carIsValid() {
		        Car car = new Car( "Morris", "DD-AB-123", 2 );

		        Set<ConstraintViolation<Car>> constraintViolations =
		                validator.validate( car );

		        assertEquals( 0, constraintViolations.size() );
		    }
		}	

2. Declaring and validating

	2.1 Declaring bean constraints

		2.1.1 Field-level constraints

			public class Car {

			    @NotNull
			    private String manufacturer;

			    @AssertTrue
			    private boolean isRegistered;

			    public Car(String manufacturer, boolean isRegistered) {
			        this.manufacturer = manufacturer;
			        this.isRegistered = isRegistered;
			    }

			    //getters and setters...
			}

			tips: 
				1. Constraints can be applied to fields of any access type (public, private etc.). Constraints on static fields are not supported
				2. When validating byte code enhanced objects, property level constraints should be used, because the byte code enhancing library won’t be able to determine a field access via reflection

		2.1.2 Property-level

			public class Car {

			    private String manufacturer;

			    private boolean isRegistered;

			    public Car(String manufacturer, boolean isRegistered) {
			        this.manufacturer = manufacturer;
			        this.isRegistered = isRegistered;
			    }

			    @NotNull
			    public String getManufacturer() {
			        return manufacturer;
			    }

			    public void setManufacturer(String manufacturer) {
			        this.manufacturer = manufacturer;
			    }

			    @AssertTrue
			    public boolean isRegistered() {
			        return isRegistered;
			    }

			    public void setRegistered(boolean isRegistered) {
			        this.isRegistered = isRegistered;
			    }
			}

			tips:
				1. The property’s getter method has to be annotated, not its setter. That way also read-only properties can be constrained which have no setter method.
				2. It is recommended to stick either to field or property annotations within one class. It is not recommended to annotate a field and the accompanying getter method as this would cause the field to be validated twice.

		2.1.3 Container element constraints
		
			This requires that ElementType.TYPE_USE is specified via @Target in the constraint definition. 

			Hibernate Validator validates container element constraints specified on the following standard Java containers:

				* implementations of java.util.Iterable (e.g. Lists, Sets),
				* implementations of java.util.Map, with support for keys and values,
				* java.util.Optional, java.util.OptionalInt, java.util.OptionalDouble, java.util.OptionalLong,
				* the various implementations of JavaFX’s javafx.beans.observable.ObservableValue.

			tips:
				
				1. In versions prior to 6, a subset of container element constraints were supported. A @Valid annotation was required at the container level to enable them. This is not required anymore as of Hibernate Validator 6.

			2.1.3.1  With Iterable

				When applying constraints on an Iterable type argument, Hibernate Validator will validate each element. 

				public class Car {

				    private Set<@ValidPart String> parts = new HashSet<>();

				    public void addPart(String part) {
				        parts.add( part );
				    }

				    //...

				}			

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.byProvider( HibernateValidator.class )
								.configure()
								.buildValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void validateSetContainerElementConstraint() {
						//tag::validateSetContainerElementConstraint[]
						Car car = new Car();
						car.addPart( "Wheel" );
						car.addPart( null );

						Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

						assertEquals( 1, constraintViolations.size() );

						ConstraintViolation<Car> constraintViolation =
								constraintViolations.iterator().next();
						assertEquals(
								"'null' is not a valid car part.",
								constraintViolation.getMessage()
						);
						assertEquals( "parts[].<iterable element>",
								constraintViolation.getPropertyPath().toString() );
						//end::validateSetContainerElementConstraint[]
					}
				}

				@Documented
				@Constraint(validatedBy = { ValidPart.ValidPartValidator.class })
				@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
				@Retention(RUNTIME)
				public @interface ValidPart {
					String message() default "{org.hibernate.validator.referenceguide.chapter02.containerelement.ValidPart.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };

					class ValidPartValidator
							implements ConstraintValidator<ValidPart, String> {

						@Override
						public void initialize(ValidPart annotation) {
						}

						@Override
						public boolean isValid(String value, ConstraintValidatorContext context) {
							return value != null;
						}
					}
				}

			2.1.3.2 With List	        

				When applying constraints on a List type argument, Hibernate Validator will validate each element. 

				public class Car {

				    private List<@ValidPart String> parts = new ArrayList<>();

				    public void addPart(String part) {
				        parts.add( part );
				    }

				    //...

				}

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.byProvider( HibernateValidator.class )
								.configure()
								.buildValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void validateListContainerElementConstraint() {
						//tag::validateListContainerElementConstraint[]
						Car car = new Car();
						car.addPart( "Wheel" );
						car.addPart( null );

						Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

						assertEquals( 1, constraintViolations.size() );

						ConstraintViolation<Car> constraintViolation =
								constraintViolations.iterator().next();
						assertEquals(
								"'null' is not a valid car part.",
								constraintViolation.getMessage()
						);
						assertEquals( "parts[1].<list element>",
								constraintViolation.getPropertyPath().toString() );
						//end::validateListContainerElementConstraint[]
					}

				}

			2.1.3.3 With Map		        

				Container element constraints are also validated on map keys and values.

				public class Car {

					public enum FuelConsumption {
						CITY,
						HIGHWAY
					}

					private Map<@NotNull FuelConsumption, @MaxAllowedFuelConsumption Integer> fuelConsumption = new HashMap<>();

					public void setFuelConsumption(FuelConsumption consumption, int value) {
						fuelConsumption.put( consumption, value );
					}

					//...

				}

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.byProvider( HibernateValidator.class )
								.configure()
								.buildValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void validateMapValueContainerElementConstraint() {
						//tag::validateMapValueContainerElementConstraint[]
						Car car = new Car();
						car.setFuelConsumption( Car.FuelConsumption.HIGHWAY, 20 );

						Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

						assertEquals( 1, constraintViolations.size() );

						ConstraintViolation<Car> constraintViolation =
								constraintViolations.iterator().next();
						assertEquals(
								"20 is outside the max fuel consumption.",
								constraintViolation.getMessage()
						);
						assertEquals(
								"fuelConsumption[HIGHWAY].<map value>",
								constraintViolation.getPropertyPath().toString()
						);
						//end::validateMapValueContainerElementConstraint[]
					}

					@Test
					public void validateMapKeyContainerElementConstraint() {
						//tag::validateMapKeyContainerElementConstraint[]
						Car car = new Car();
						car.setFuelConsumption( null, 5 );

						Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

						assertEquals( 1, constraintViolations.size() );

						ConstraintViolation<Car> constraintViolation =
								constraintViolations.iterator().next();
						assertEquals(
								"must not be null",
								constraintViolation.getMessage()
						);
						assertEquals(
								"fuelConsumption<K>[].<map key>",
								constraintViolation.getPropertyPath().toString()
						);
						//end::validateMapKeyContainerElementConstraint[]
					}
				}

				@Documented
				@Constraint(validatedBy = { MaxAllowedFuelConsumption.MaxAllowedFuelConsumptionValidator.class })
				@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
				@Retention(RUNTIME)
				public @interface MaxAllowedFuelConsumption {
					String message() default "{org.hibernate.validator.referenceguide.chapter02.containerelement.MaxAllowedFuelConsumption.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };

					class MaxAllowedFuelConsumptionValidator implements ConstraintValidator<MaxAllowedFuelConsumption, Integer> {

						@Override
						public void initialize(MaxAllowedFuelConsumption annotation) {
						}

						@Override
						public boolean isValid(Integer value, ConstraintValidatorContext context) {
							if ( value == null ) {
								return true;
							}

							return value >= 0 && value <= 10;
						}
					}
				}


			2.1.3.4 With java.util.Optional

				When applying a constraint on the type argument of Optional, Hibernate Validator will automatically unwrap the type and validate the internal value.

				public class Car {

					private Optional<@MinTowingCapacity(1000) Integer> towingCapacity = Optional.empty();

					public void setTowingCapacity(Integer alias) {
						towingCapacity = Optional.of( alias );
					}

					//...

				}

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.byProvider( HibernateValidator.class )
								.configure()
								.buildValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void validateOptionalContainerElementConstraint() {
						//tag::validateOptionalContainerElementConstraint[]
						Car car = new Car();
						car.setTowingCapacity( 100 );

						Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

						assertEquals( 1, constraintViolations.size() );

						ConstraintViolation<Car> constraintViolation = constraintViolations.iterator().next();
						assertEquals(
								"Not enough towing capacity.",
								constraintViolation.getMessage()
						);
						assertEquals(
								"towingCapacity",
								constraintViolation.getPropertyPath().toString()
						);
						//end::validateOptionalContainerElementConstraint[]
					}

				}

				@Documented
				@Constraint(validatedBy = { MinTowingCapacity.MinTowingCapacityValidator.class })
				@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
				@Retention(RUNTIME)
				public @interface MinTowingCapacity {
					long value();

					String message() default "{org.hibernate.validator.referenceguide.chapter02.containerelement.MinTowingCapacity.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };

					class MinTowingCapacityValidator implements ConstraintValidator<MinTowingCapacity, Integer> {
						private long min;

						@Override
						public void initialize(MinTowingCapacity annotation) {
							min = annotation.value();
						}

						@Override
						public boolean isValid(Integer value, ConstraintValidatorContext context) {
							if ( value == null ) {
								return true;
							}

							return value >= min;
						}
					}
				}


			2.1.3.5 With custom container types		

				Container element constraints can also be used with custom containers.

				public class Car {

					private GearBox<@MinTorque(100) Gear> gearBox;

					public void setGearBox(GearBox<Gear> gearBox) {
						this.gearBox = gearBox;
					}

					//...

				}

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.byProvider( HibernateValidator.class )
								.configure()
								.addValueExtractor( new GearBoxValueExtractor() )
								.buildValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void validateCustomContainerElementConstraint() {
						//tag::validateCustomContainerElementConstraint[]
						Car car = new Car();
						car.setGearBox( new GearBox<>( new Gear.AcmeGear() ) );

						Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );
						assertEquals( 1, constraintViolations.size() );

						ConstraintViolation<Car> constraintViolation =
								constraintViolations.iterator().next();
						assertEquals(
								"Gear is not providing enough torque.",
								constraintViolation.getMessage()
						);
						assertEquals(
								"gearBox",
								constraintViolation.getPropertyPath().toString()
						);
						//end::validateCustomContainerElementConstraint[]
					}

				}

				public class Gear {
					private final Integer torque;

					public Gear(Integer torque) {
						this.torque = torque;
					}

					public Integer getTorque() {
						return torque;
					}

					public static class AcmeGear extends Gear {
						public AcmeGear() {
							super( 60 );
						}
					}
				}

				public class GearBox<T extends Gear> {

					private final T gear;

					public GearBox(T gear) {
						this.gear = gear;
					}

					public Gear getGear() {
						return this.gear;
					}
				}

				public class GearBoxValueExtractor implements ValueExtractor<GearBox<@ExtractedValue ?>> {

					@Override
					public void extractValues(GearBox<@ExtractedValue ?> originalValue, ValueExtractor.ValueReceiver receiver) {
						receiver.value( null, originalValue.getGear() );
					}
				}

				@Documented
				@Constraint(validatedBy = { MinTorque.MinTorqueValidator.class })
				@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
				@Retention(RUNTIME)
				public @interface MinTorque {
					long value();

					String message() default "{org.hibernate.validator.referenceguide.chapter02.containerelement.MinTorque.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };

					class MinTorqueValidator implements ConstraintValidator<MinTorque, Gear> {
						private long min;

						@Override
						public void initialize(MinTorque annotation) {
							this.min = annotation.value();
						}

						@Override
						public boolean isValid(Gear gear, ConstraintValidatorContext context) {
							if ( gear == null ) {
								return true;
							}

							return gear.getTorque() > min;
						}
					}
				}


			2.1.3.6 Nested container elements			

				Constraints are also supported on nested container elements.
				When validating a Car object, both the @NotNull constraints on Part and Manufacturer will be enforced.

				public class Car {

					private Map<@NotNull Part, List<@NotNull Manufacturer>> partManufacturers =
							new HashMap<>();

					//...
				}

				public class Manufacturer {

					@NotNull
					private String name;

					//...
				}

				public class Part {

					@NotNull
					private String name;

					//...
				}

		2.1.4 Class-level constraints	

			@ValidPassengerCount
			public class Car {

				private int seatCount;

				private List<Person> passengers;

				//...
			}

			public class Person {}

			@Target({ TYPE, ANNOTATION_TYPE })
			@Retention(RUNTIME)
			@Constraint(validatedBy = { ValidPassengerCount.Validator.class })
			@Documented
			public @interface ValidPassengerCount {

				String message() default "{org.hibernate.validator.referenceguide.chapter02.classlevel.ValidPassengerCount.message}";

				Class<?>[] groups() default { };

				Class<? extends Payload>[] payload() default { };

				class Validator
						implements ConstraintValidator<ValidPassengerCount, Car> {

					@Override
					public void initialize(ValidPassengerCount constraintAnnotation) {
					}

					@Override
					public boolean isValid(Car car, ConstraintValidatorContext context) {
						return false;
					}
				}
			}

		2.1.5 Constraint inheritance

			When a class implements an interface or extends another class, all constraint annotations declared on the super-type apply in the same manner as the constraints specified on the class itself. 

			public class Car {

			    private String manufacturer;

			    @NotNull
			    public String getManufacturer() {
			        return manufacturer;
			    }

			    //...
			}

			public class RentalCar extends Car {

			    private String rentalStation;

			    @NotNull
			    public String getRentalStation() {
			        return rentalStation;
			    }

			    //...
			}

		2.1.6 Object graphs
		
			The Bean Validation API does not only allow to validate single class instances but also complete object graphs (cascaded validation). To do so, just annotate a field or property representing a reference to another object with @Valid

			public class Car {

			    @NotNull
			    @Valid
			    private Person driver;

			    //...
			}	

			public class Person {

			    @NotNull
			    private String name;

			    //...
			}

			Cascaded validation is also supported for nested container elements.	

			public class Car {

				private List<@NotNull @Valid Person> passengers = new ArrayList<Person>();

				private Map<@Valid Part, List<@Valid Manufacturer>> partManufacturers = new HashMap<>();

				//...
			}

			public class Manufacturer {

				@NotNull
				private String name;

				//...
			}	

			public class Part {

				@NotNull
				private String name;

				//...
			}

			public class Person {

				@NotNull
				private String name;

				//...
			}

	2.2 Validating bean constraints

		2.2.1 Obtaing a Validator instance

			ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();
			Validator validator = validatorFactory.getValidator();

		2.2.2 Validator methods
		
			Validator#validate()

				Car car = new Car(null, true);
				Set<ConstraintViolation<Car>> constraintViolations = validator.validate(car);

			Validator#valiateProperty()	

				Car car = new Car(null, true);
				Set<ConstraintViolation<Car>> constraintViolations = validator.validateProperty(car, "manufacturer");

			Validator#valiateValue()	

				Car car = new Car(null, true);
				Set<ConstraintViolation<Car>> constraintViolations = validator.validateValue(Car.class, "manufacturer", null);

			tips:
				@Valid not honored by validatePropety() and validateValue();

		2.2.3 ConstraintViolation methods
		
			getMessage();
			getMessageTemplate();		
			getRootBean();
			getRootBeanClass();
			getLeafBean();
			getPropertyPath();
			getInvalidValue();
			getConstraintDescriptor();

	2.3 Built-in constraints		

		2.3.1 Bean Validation constraints

			@AssertFalse
				Checks that the annotated element is false
				Supported data types
					Boolean, boolean
				Hibernate metadata impact
					None

			@AssertTrue
				Checks that the annotated element is true
				Supported data types
					Boolean, boolean
				Hibernate metadata impact
					None

			@DecimalMax(value=, inclusive=)
				Checks whether the annotated value is less than the specified maximum, when inclusive=false. Otherwise whether the value is less than or equal to the specified maximum. The parameter value is the string representation of the max value according to the BigDecimal string representation.
				Supported data types
					BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of Number and javax.money.MonetaryAmount (if the JSR 354 API and an implementation is on the class path)
				Hibernate metadata impact
					None

			@DecimalMin(value=, inclusive=)
				Checks whether the annotated value is larger than the specified minimum, when inclusive=false. Otherwise whether the value is larger than or equal to the specified minimum. The parameter value is the string representation of the min value according to the BigDecimal string representation.
				Supported data types
					BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of Number and javax.money.MonetaryAmount
				Hibernate metadata impact
					None

			@Digits(integer=, fraction=)
				Checks whether the annotated value is a number having up to integer digits and fraction fractional digits
				Supported data types
					BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of Number
				Hibernate metadata impact
					Defines column precision and scale

			@Email
				Checks whether the specified character sequence is a valid email address. The optional parameters regexp and flags allow to specify an additional regular expression (including regular expression flags) which the email must match.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@Future
				Checks whether the annotated date is in the future
				Supported data types
					java.util.Date, java.util.Calendar, java.time.Instant, java.time.LocalDate, java.time.LocalDateTime, java.time.LocalTime, java.time.MonthDay, java.time.OffsetDateTime, java.time.OffsetTime, java.time.Year, java.time.YearMonth, java.time.ZonedDateTime, java.time.chrono.HijrahDate, java.time.chrono.JapaneseDate, java.time.chrono.MinguoDate, java.time.chrono.ThaiBuddhistDate; additionally supported by HV, if the Joda Time date/time API is on the classpath: any implementations of ReadablePartial and ReadableInstant
				Hibernate metadata impact
					None

			@FutureOrPresent
				Checks whether the annotated date is in the present or in the future
				Supported data types
					java.util.Date, java.util.Calendar, java.time.Instant, java.time.LocalDate, java.time.LocalDateTime, java.time.LocalTime, java.time.MonthDay, java.time.OffsetDateTime, java.time.OffsetTime, java.time.Year, java.time.YearMonth, java.time.ZonedDateTime, java.time.chrono.HijrahDate, java.time.chrono.JapaneseDate, java.time.chrono.MinguoDate, java.time.chrono.ThaiBuddhistDate; additionally supported by HV, if the Joda Time date/time API is on the classpath: any implementations of ReadablePartial and ReadableInstant
				Hibernate metadata impact
					None

			@Max(value=)
				Checks whether the annotated value is less than or equal to the specified maximum
				Supported data types
					BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the character sequence is evaluated), any sub-type of Number and javax.money.MonetaryAmount
				Hibernate metadata impact
					Adds a check constraint on the column

			@Min(value=)
				Checks whether the annotated value is higher than or equal to the specified minimum
				Supported data types
					BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the character sequence is evaluated), any sub-type of Number and javax.money.MonetaryAmount
				Hibernate metadata impact
					Adds a check constraint on the column

			@NotBlank
				Checks that the annotated character sequence is not null and the trimmed length is greater than 0. The difference to @NotEmpty is that this constraint can only be applied on character sequences and that trailing white-spaces are ignored.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@NotEmpty
				Checks whether the annotated element is not null nor empty
				Supported data types
					CharSequence, Collection, Map and arrays
				Hibernate metadata impact
					None

			@NotNull
				Checks that the annotated value is not null
				Supported data types
					Any type
				Hibernate metadata impact
					Column(s) are not nullable

			@Negative
				Checks if the element is strictly negative. Zero values are considered invalid.
				Supported data types
					BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the character sequence is evaluated), any sub-type of Number and javax.money.MonetaryAmount
				Hibernate metadata impact
					None

			@NegativeOrZero
				Checks if the element is negative or zero.
				Supported data types
					BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the character sequence is evaluated), any sub-type of Number and javax.money.MonetaryAmount
				Hibernate metadata impact
					None

			@Null
				Checks that the annotated value is null
				Supported data types
					Any type
				Hibernate metadata impact
					None

			@Past
				Checks whether the annotated date is in the past
				Supported data types
					java.util.Date,java.util.Calendar, java.time.Instant, java.time.LocalDate, java.time.LocalDateTime, java.time.LocalTime, java.time.MonthDay, java.time.OffsetDateTime, java.time.OffsetTime, java.time.Year, java.time.YearMonth, java.time.ZonedDateTime, java.time.chrono.HijrahDate, java.time.chrono.JapaneseDate, java.time.chrono.MinguoDate, java.time.chrono.ThaiBuddhistDate; Additionally supported by HV, if the Joda Time date/time API is on the classpath: any implementations of ReadablePartial and ReadableInstant
				Hibernate metadata impact
					None

			@PastOrPresent
				Checks whether the annotated date is in the past or in the present
				Supported data types
					java.util.Date,java.util.Calendar, java.time.Instant, java.time.LocalDate, java.time.LocalDateTime, java.time.LocalTime, java.time.MonthDay, java.time.OffsetDateTime, java.time.OffsetTime, java.time.Year, java.time.YearMonth, java.time.ZonedDateTime, java.time.chrono.HijrahDate, java.time.chrono.JapaneseDate, java.time.chrono.MinguoDate, java.time.chrono.ThaiBuddhistDate; Additionally supported by HV, if the Joda Time date/time API is on the classpath: any implementations of ReadablePartial and ReadableInstant
				Hibernate metadata impact
					None

			@Pattern(regex=, flags=)
				Checks if the annotated string matches the regular expression regex considering the given flag match
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@Positive
				Checks if the element is strictly positive. Zero values are considered invalid.
				Supported data types
					BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the character sequence is evaluated), any sub-type of Number and javax.money.MonetaryAmount
				Hibernate metadata impact
					None

			@PositiveOrZero
				Checks if the element is positive or zero.
				Supported data types
					BigDecimal, BigInteger, byte, short, int, long and the respective wrappers of the primitive types; additionally supported by HV: any sub-type of CharSequence (the numeric value represented by the character sequence is evaluated), any sub-type of Number and javax.money.MonetaryAmount
				Hibernate metadata impact
					None

			@Size(min=, max=)
				Checks if the annotated element’s size is between min and max (inclusive)
				Supported data types
					CharSequence, Collection, Map and arrays
				Hibernate metadata impact
					Column length will be set to max

		2.3.3 Additional constraints
		
			@CreditCardNumber(ignoreNonDigitCharacters=)
				Checks that the annotated character sequence passes the Luhn checksum test. Note, this validation aims to check for user mistakes, not credit card validity! See also Anatomy of a credit card number. ignoreNonDigitCharacters allows to ignore non digit characters. The default is false.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@Currency(value=)
				Checks that the currency unit of the annotated javax.money.MonetaryAmount is part of the specified currency units.
				Supported data types
					any sub-type of javax.money.MonetaryAmount (if the JSR 354 API and an implementation is on the class path)
				Hibernate metadata impact
					None

			@DurationMax(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=)
				Checks that annotated java.time.Duration element is not greater than the one constructed from annotation parameters. Equality is allowed if inclusive flag is set to true.
				Supported data types
					java.time.Duration
				Hibernate metadata impact
					None

			@DurationMin(days=, hours=, minutes=, seconds=, millis=, nanos=, inclusive=)
				Checks that annotated java.time.Duration element is not less than the one constructed from annotation parameters. Equality is allowed if inclusive flag is set to true.
				Supported data types
					java.time.Duration
				Hibernate metadata impact
					None

			@EAN
				Checks that the annotated character sequence is a valid EAN barcode. type determines the type of barcode. The default is EAN-13.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@ISBN
				Checks that the annotated character sequence is a valid ISBN. type determines the type of ISBN. The default is ISBN-13.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@Length(min=, max=)
				Validates that the annotated character sequence is between min and max included
				Supported data types
					CharSequence
				Hibernate metadata impact
					Column length will be set to max

			@CodePointLength(min=, max=, normalizationStrategy=)
				Validates that code point length of the annotated character sequence is between min and max included. Validates normalized value if normalizationStrategy is set.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@LuhnCheck(startIndex= , endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=)
				Checks that the digits within the annotated character sequence pass the Luhn checksum algorithm (see also Luhn algorithm). startIndex and endIndex allow to only run the algorithm on the specified sub-string. checkDigitIndex allows to use an arbitrary digit within the character sequence as the check digit. If not specified it is assumed that the check digit is part of the specified range. Last but not least, ignoreNonDigitCharacters allows to ignore non digit characters.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@Mod10Check(multiplier=, weight=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=)
				Checks that the digits within the annotated character sequence pass the generic mod 10 checksum algorithm. multiplier determines the multiplier for odd numbers (defaults to 3), weight the weight for even numbers (defaults to 1). startIndex and endIndex allow to only run the algorithm on the specified sub-string. checkDigitIndex allows to use an arbitrary digit within the character sequence as the check digit. If not specified it is assumed that the check digit is part of the specified range. Last but not least, ignoreNonDigitCharacters allows to ignore non digit characters.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@Mod11Check(threshold=, startIndex=, endIndex=, checkDigitIndex=, ignoreNonDigitCharacters=, treatCheck10As=, treatCheck11As=)
				Checks that the digits within the annotated character sequence pass the mod 11 checksum algorithm. threshold specifies the threshold for the mod11 multiplier growth; if no value is specified the multiplier will grow indefinitely. treatCheck10As and treatCheck11As specify the check digits to be used when the mod 11 checksum equals 10 or 11, respectively. Default to X and 0, respectively. startIndex, endIndex checkDigitIndex and ignoreNonDigitCharacters carry the same semantics as in @Mod10Check.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@Range(min=, max=)
				Checks whether the annotated value lies between (inclusive) the specified minimum and maximum
				Supported data types
					BigDecimal, BigInteger, CharSequence, byte, short, int, long and the respective wrappers of the primitive types
				Hibernate metadata impact
					None

			@SafeHtml(whitelistType= , additionalTags=, additionalTagsWithAttributes=, baseURI=)
				Checks whether the annotated value contains potentially malicious fragments such as <script/>. In order to use this constraint, the jsoup library must be part of the class path. With the whitelistType attribute a predefined whitelist type can be chosen which can be refined via additionalTags or additionalTagsWithAttributes. The former allows to add tags without any attributes, whereas the latter allows to specify tags and optionally allowed attributes as well as accepted protocols for the attributes using the annotation @SafeHtml.Tag. In addition, baseURI allows to specify the base URI used to resolve relative URIs.
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			@ScriptAssert(lang=, script=, alias=, reportOn=)
				Checks whether the given script can successfully be evaluated against the annotated element. In order to use this constraint, an implementation of the Java Scripting API as defined by JSR 223 ("Scripting for the JavaTM Platform") must be a part of the class path. The expressions to be evaluated can be written in any scripting or expression language, for which a JSR 223 compatible engine can be found in the class path. Even though this is a class-level constraint, one can use the reportOn attribute to report a constraint violation on a specific property rather than the whole object.
				Supported data types
					Any type
				Hibernate metadata impact
					None

			@UniqueElements
				Checks that the annotated collection only contains unique elements. The equality is determined using the equals() method. The default message does not include the list of duplicate elements but you can include it by overriding the message and using the {duplicates} message parameter. The list of duplicate elements is also included in the dynamic payload of the constraint violation.
				Supported data types
					Collection
				Hibernate metadata impact
					None

			@URL(protocol=, host=, port=, regexp=, flags=)
				Checks if the annotated character sequence is a valid URL according to RFC2396. If any of the optional parameters protocol, host or port are specified, the corresponding URL fragments must match the specified values. The optional parameters regexp and flags allow to specify an additional regular expression (including regular expression flags) which the URL must match. Per default this constraint used the java.net.URL constructor to verify whether a given string represents a valid URL. A regular expression based version is also available - RegexpURLValidator - which can be configured via XML (see Section 8.2, “Mapping constraints via constraint-mappings”) or the programmatic API (see Section 12.13.2, “Adding constraint definitions programmatically”).
				Supported data types
					CharSequence
				Hibernate metadata impact
					None

			2.3.2.1 Country specific constraints
			
				@CNPJ
					Checks that the annotated character sequence represents a Brazilian corporate tax payer registry number (Cadastro de Pessoa Juríeddica)
					Supported data types
						CharSequence
					Hibernate metadata impact
						None
					Country
						Brazil

				@CPF
					Checks that the annotated character sequence represents a Brazilian individual taxpayer registry number (Cadastro de Pessoa Fídsica)
					Supported data types
						CharSequence
					Hibernate metadata impact
						None
					Country
						Brazil

				@TituloEleitoral
					Checks that the annotated character sequence represents a Brazilian voter ID card number (Título Eleitoral)
					Supported data types
						CharSequence
					Hibernate metadata impact
						None
					Country
						Brazil

				@NIP
					Checks that the annotated character sequence represents a Polish VAT identification number (NIP)
					Supported data types
						CharSequence
					Hibernate metadata impact
						None
					Country
						Poland

				@PESEL
					Checks that the annotated character sequence represents a Polish national identification number (PESEL)
					Supported data types
						CharSequence
					Hibernate metadata impact
						None
					Country
						Poland

				@REGON
					Checks that the annotated character sequence represents a Polish taxpayer identification number (REGON). Can be applied to both 9 and 14 digits versions of REGON
					Supported data types
						CharSequence
					Hibernate metadata impact
						None
					Country
						Poland			 

	3. Declaring and validating method constraints

		3.1 Declaring method constraints

			3.1.1 Parameter constraints

				public class RentalStation {

					public RentalStation(@NotNull String name) {
						// ...
					}

					public void rentCar(
							@NotNull Customer customer, 
							@NotNull @Future Date startDate, 
							@Min(1) int durationDays) {
						// ...		
					}

				}

				public class Customer {}

				3.1.1.1 Cross-parameter constraints

					Declaring a cross-parameter constraint

						public class Car {

						    @LuggageCountMatchesPassengerCount(piecesOfLuggagePerPassenger = 2)
						    public void load(List<Person> passengers, List<PieceOfLuggage> luggage) {
						        //...
						    }
						}

						@Target({ METHOD, ANNOTATION_TYPE })
						@Retention(RUNTIME)
						@Constraint(validatedBy = { LuggageCountMatchesPassengerCount.Validator.class })
						@Documented
						public @interface LuggageCountMatchesPassengerCount {

							String message() default "{org.hibernate.validator.referenceguide.chapter03.crossparameter.LuggageCountMatchesPassengerCount.message}";

							Class<?>[] groups() default { };

							Class<? extends Payload>[] payload() default { };

							ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;

							int piecesOfLuggagePerPassenger() default 1;

							@SupportedValidationTarget({
									ValidationTarget.PARAMETERS,
									ValidationTarget.ANNOTATED_ELEMENT
							})
							class Validator
									implements ConstraintValidator<LuggageCountMatchesPassengerCount, Object[]> {

								@Override
								public void initialize(LuggageCountMatchesPassengerCount constraintAnnotation) {
								}

								@Override
								public boolean isValid(Object[] value, ConstraintValidatorContext context) {
									return false;
								}
							}
						}	

					Specifying a constraint’s target		

						public class Garage {

							@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.PARAMETERS)
							public Car buildCar(List<Part> parts) {
								//...
								return null;
							}

							@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.RETURN_VALUE)
							public Car paintCar(int color) {
								//...
								return null;
							}
						}

						@Target({ METHOD, ANNOTATION_TYPE })
						@Retention(RUNTIME)
						@Constraint(validatedBy = { ELAssert.Validator.class })
						@Documented
						public @interface ELAssert {

							String message() default "{org.hibernate.validator.referenceguide.chapter03.crossparameter.ELAssert.message}";

							Class<?>[] groups() default { };

							Class<? extends Payload>[] payload() default { };

							ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;

							String expression();

							@SupportedValidationTarget({
									ValidationTarget.PARAMETERS,
									ValidationTarget.ANNOTATED_ELEMENT
							})
							class Validator
									implements ConstraintValidator<ELAssert, Object[]> {

								@Override
								public void initialize(ELAssert constraintAnnotation) {
								}

								@Override
								public boolean isValid(Object[] value, ConstraintValidatorContext context) {
									return false;
								}
							}
						}

						public class Car {}
						public class Part {}

			3.1.3. Cascaded validation			

				Marking executable parameters and return values for cascaded validation

					public class Garage {

						@NotNull
						private String name;

						@Valid
						public Garage(String name) {
							this.name = name;
						}

						public boolean checkCar(@Valid @NotNull Car car) {
							//...
							return false;
						}
					}

					public class Car {

						@NotNull
						private String manufacturer;

						@NotNull
						@Size(min = 2, max = 14)
						private String licensePlate;

						public Car(String manufacturer, String licencePlate) {
							this.manufacturer = manufacturer;
							this.licensePlate = licencePlate;
						}

						//getters and setters ...
					}

					public class GarageTest {

						private static ExecutableValidator executableValidator;

						@BeforeClass
						public static void setUpValidator() {
							ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
							executableValidator = factory.getValidator().forExecutables();
						}

						@Test
						public void cascadedMethodParameterValidation() throws Exception {
							//cascaded method parameter
							Garage object = new Garage( "Bob's Auto Shop" );
							Method method = Garage.class.getMethod( "checkCar", Car.class );
							Object[] parameterValues = { new Car( "Morris", "A" ) };

							Set<ConstraintViolation<Garage>> violations = executableValidator.validateParameters(
									object,
									method,
									parameterValues
							);

							//Car#licensePlate is too short
							assertEquals( 1, violations.size() );
							ConstraintViolation<Garage> violation = violations.iterator().next();
							assertEquals(
									Size.class,
									violation.getConstraintDescriptor().getAnnotation().annotationType()
							);
						}

						@Test
						public void cascadedConstructorReturnValueValidation() throws Exception {
							//cascaded constructor return value
							Constructor<Garage> constructor = Garage.class.getConstructor( String.class );
							Garage createdObject = new Garage( null );

							Set<ConstraintViolation<Garage>> violations = executableValidator.validateConstructorReturnValue(
									constructor,
									createdObject
							);

							//Garage#name is null
							assertEquals( 1, violations.size() );
							ConstraintViolation<Garage> violation = violations.iterator().next();
							assertEquals(
									NotNull.class,
									violation.getConstraintDescriptor().getAnnotation().annotationType()
							);
						}
					}

			3.1.4. Method constraints in inheritance hierarchies
			
				When declaring method constraints in inheritance hierarchies, it is important to be aware of the following rules:

					* The preconditions to be satisfied by the caller of a method may not be strengthened in subtypes
					* The postconditions guaranteed to the caller of a method may not be weakened in subtypes

		3.2 Validating method constraints

			3.2.1. Obtaining an ExecutableValidator instance

				ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
				executableValidator = factory.getValidator().forExecutables();

			3.2.2. ExecutableValidator methods	

				public class Car {

				    public Car(@NotNull String manufacturer) {

				    }

				    @ValidRacingCar
				    public Car(String manufacturer, String team) {

				    }

				    public void drive(@Max(75) int speedInMph) {

				    }

				    @Size(min = 1)
				    public List<Passenger> getPassengers() {
				        return Collections.emptyList();
				    }

				}

				public class Passenger {}

				@Target({METHOD, CONSTRUCTOR, ANNOTATION_TYPE})
					@Retention(RUNTIME)
					@Constraint(validatedBy = {ValidRacingCar.Validator.class})
					@Documented
					public @interface ValidRacingCar {

					    String message() default "{com.binvi.springboot.demo03.validator.referenceguide.chapter03.validation.ValidRacingCar.message}";

					    Class<?>[] groups() default {};

					    Class<? extends Payload>[] payload() default {};

					    class Validator implements ConstraintValidator<ValidRacingCar, Car> {

					        @Override
					        public void initialize(ValidRacingCar ConstraintAnnotation) { }

					        @Override
					        public boolean isValid(Car value, ConstraintValidatorContext context) {
					            return false;
					        }
					    }

					}

					public class CarTest {

					    private static ExecutableValidator executableValidator;

					    @BeforeClass
					    public static void setUpValidator() {
					        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
					        executableValidator = factory.getValidator().forExecutables();
					    }

					    @Test
					    public void validateParameters() throws Exception {
					        Car object = new Car("Morris");
					        Method method = Car.class.getMethod("drive", int.class);
					        Object[] parameterValues = {80};
					        Set<ConstraintViolation<Car>> violations = executableValidator.validateParameters(
					                object,
					                method,
					                parameterValues
					        );

					        assertEquals(1, violations.size());
					        Class<? extends Annotation> constraintType = violations.iterator()
					                .next()
					                .getConstraintDescriptor()
					                .getAnnotation()
					                .annotationType();
					        assertEquals(Max.class, constraintType);
					    }

					    @Test
					    public void validateReturnValue() throws Exception {
					        Car object = new Car("Morris");
					        Method method = Car.class.getMethod("getPassengers");
					        Object returnValue = Collections.<Passenger>emptyList();
					        Set<ConstraintViolation<Car>> violations = executableValidator.validateReturnValue(
					                object,
					                method,
					                returnValue
					        );

					        assertEquals(1, violations.size());
					        Class<? extends Annotation> constraintType = violations.iterator()
					                .next()
					                .getConstraintDescriptor()
					                .getAnnotation()
					                .annotationType();
					        assertEquals(Size.class, constraintType);
					    }

					    @Test
					    public void validateConstructorParameters() throws Exception {
					        Constructor<Car> constructor = Car.class.getConstructor(String.class);
					        Object[] parameterValues = { null };
					        Set<ConstraintViolation<Car>> violations = executableValidator.validateConstructorParameters(
					                constructor,
					                parameterValues
					        );

					        assertEquals(1, violations.size());
					        Class<? extends Annotation> annotationType = violations.iterator()
					                .next()
					                .getConstraintDescriptor()
					                .getAnnotation()
					                .annotationType();
					        assertEquals(NotNull.class, annotationType);
					    }

					    @Test
					    public void validateConstructorReturnValue() throws Exception {
					        Constructor<Car> constructor = Car.class.getConstructor(String.class, String.class);
					        Car createObject = new Car("Morris", null);
					        Set<ConstraintViolation<Car>> violations = executableValidator.validateConstructorReturnValue(
					                constructor,
					                createObject
					        );

					        assertEquals(1, violations.size());
					        Class<? extends Annotation> annotationType = violations.iterator()
					                .next()
					                .getConstraintDescriptor()
					                .getAnnotation()
					                .annotationType();
					        assertEquals(ValidRacingCar.class, annotationType);
					    }

					    @Test
					    public void retrieveMethodAndParametersInfomation() throws Exception {
					        Car object = new Car("Morris");
					        Method method = Car.class.getMethod("drive", int.class);
					        Object[] parameterValues = { 80 };
					        Set<ConstraintViolation<Car>> violations = executableValidator.validateParameters(
					                object,
					                method,
					                parameterValues
					        );

					        assertEquals(1, violations.size());
					        Iterator<Node> propertyPath = violations.iterator()
					                .next()
					                .getPropertyPath()
					                .iterator();

					        MethodNode methodNode = propertyPath.next().as(MethodNode.class);
					        assertEquals("drive", methodNode.getName());
					        assertEquals(Arrays.<Class<?>>asList(int.class), methodNode.getParameterTypes());

					        ParameterNode parameterNode = propertyPath.next().as(ParameterNode.class);
					        assertEquals("arg0", parameterNode.getName());
					        assertEquals(0, parameterNode.getParameterIndex());
					    }

					}

		3.3 Built-in method constraints

			public class Car {

			    @ParameterScriptAssert(lang = "javascript", script = "arg1.size() <= arg0.size() * 2")
			    public void load(List<Person> passengers, List<PieceOfLuggage> luggage) {
			        // ...
			    }

			}

			public class Person {}

			public class PieceOfLuggage {}

			public class ParameterScriptAssertTest {

			    private static ExecutableValidator executableValidator;

			    @BeforeClass
			    public static void setUpValidator() {
			        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
			        executableValidator = factory.getValidator().forExecutables();
			    }

			    @Test
			    public void validateParameters() throws Exception {
			        Car object = new Car();
			        Method method = Car.class.getMethod("load", List.class, List.class);
			        Object[] parameterValues = {
			                Arrays.asList(new Person()),
			                Arrays.asList(new PieceOfLuggage(), new PieceOfLuggage(), new PieceOfLuggage())
			        };

			        Set<ConstraintViolation<Car>> violations = executableValidator.validateParameters(
			                object,
			                method,
			                parameterValues
			        );
			        Assert.assertEquals(1, violations.size());
			        Class<? extends Annotation> annotationType = violations.iterator()
			                .next()
			                .getConstraintDescriptor()
			                .getAnnotation()
			                .annotationType();
			        Assert.assertEquals(ParameterScriptAssert.class, annotationType);
			    }

			}

	4. Interpolating constraint error message
	
		4.1 Default message interpolation

			public class Car {
				@NotNull(message = "The manufacturer name must not be null")
				private String manufacturer;
			}		 	

			4.1.1 Special characters
			
				\{ is considered as literal {
				\} is considered as literal }
				\$ is considered as literal $
				\\ is considered as literal \

			4.1.2 Interpolating with message expressions

				The validation engine makes the following objects available in the EL context:

					* the attribute values of the constraint mapped to the attribute names
					* the currently validated value (property, bean, method parameter etc.) under the name validatedValue
					* a bean mapped to the name formatter exposing the var-arg method format(String format, Object…​ args) which behaves like java.util.Formatter.format(String format, Object…​ args).

			4.1.3 Examples

				Specifying message descriptors

					public class Car {

						@NotNull
						private String manufacturer;

						@Size(
								min = 2,
								max = 14,
								message = "The license plate '${validatedValue}' must be between {min} and {max} characters long"
						)
						private String licensePlate;

						@Min(
								value = 2,
								message = "There must be at least {value} seat${value > 1 ? 's' : ''}"
						)
						private int seatCount;

						@DecimalMax(
								value = "350",
								message = "The top speed ${formatter.format('%1$.2f', validatedValue)} is higher " +
										"than {value}"
						)
						private double topSpeed;

						@DecimalMax(value = "100000", message = "Price must not be higher than ${value}")
						private BigDecimal price;

						public Car(
								String manufacturer,
								String licensePlate,
								int seatCount,
								double topSpeed,
								BigDecimal price) {
							this.manufacturer = manufacturer;
							this.licensePlate = licensePlate;
							this.seatCount = seatCount;
							this.topSpeed = topSpeed;
							this.price = price;
						}

						//getters and setters ...
					}

					public class CarTest {

						private static Validator validator;

						@BeforeClass
						public static void setUpValidator() {
							ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
							validator = factory.getValidator();
						}

						@Test
						public void messageDescriptors() {
							//tag::messageDescriptors[]
							Car car = new Car( null, "A", 1, 400.123456, BigDecimal.valueOf( 200000 ) );

							String message = validator.validateProperty( car, "manufacturer" )
									.iterator()
									.next()
									.getMessage();
							assertEquals( "must not be null", message );

							message = validator.validateProperty( car, "licensePlate" )
									.iterator()
									.next()
									.getMessage();
							assertEquals(
									"The license plate 'A' must be between 2 and 14 characters long",
									message
							);

							message = validator.validateProperty( car, "seatCount" ).iterator().next().getMessage();
							assertEquals( "There must be at least 2 seats", message );

							message = validator.validateProperty( car, "topSpeed" ).iterator().next().getMessage();
							assertEquals( "The top speed 400.12 is higher than 350", message );

							message = validator.validateProperty( car, "price" ).iterator().next().getMessage();
							assertEquals( "Price must not be higher than $100000", message );
							//end::messageDescriptors[]
						}
					}


		4.2. Custom message interpolation		

			Custom interpolators must implement the interface javax.validation.MessageInterpolator. Note that implementations must be thread-safe. 

			In order to use a custom message interpolator it must be registered either by ：

				2. configuring it in the Bean Validation XML descriptor META-INF/validation.xml：

					<validation-config
				        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
				        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration
				            http://xmlns.jcp.org/xml/ns/validation/configuration/validation-configuration-2.0.xsd"
				        version="2.0">

					    <default-provider>com.acme.ValidationProvider</default-provider>

					    <message-interpolator>com.acme.MessageInterpolator</message-interpolator>
					    <traversable-resolver>com.acme.TraversableResolver</traversable-resolver>
					    <constraint-validator-factory>
					        com.acme.ConstraintValidatorFactory
					    </constraint-validator-factory>
					    <parameter-name-provider>com.acme.ParameterNameProvider</parameter-name-provider>
					    <clock-provider>com.acme.ClockProvider</clock-provider>

					    <value-extractor>com.acme.ContainerValueExtractor</value-extractor>

					    <executable-validation enabled="true">
					        <default-validated-executable-types>
					            <executable-type>CONSTRUCTORS</executable-type>
					            <executable-type>NON_GETTER_METHODS</executable-type>
					            <executable-type>GETTER_METHODS</executable-type>
					        </default-validated-executable-types>
					    </executable-validation>

					    <constraint-mapping>META-INF/validation/constraints-car.xml</constraint-mapping>

					    <property name="hibernate.validator.fail_fast">false</property>
					</validation-config>

					Bean constraints configured via XML: constraints-car.xml

						<constraint-mappings
						        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
						        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
						            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
						        version="2.0">

						    <default-package>org.hibernate.validator.referenceguide.chapter05</default-package>
						    <bean class="Car" ignore-annotations="true">
						        <field name="manufacturer">
						            <constraint annotation="javax.validation.constraints.NotNull"/>
						        </field>
						        <field name="licensePlate">
						            <constraint annotation="javax.validation.constraints.NotNull"/>
						        </field>
						        <field name="seatCount">
						            <constraint annotation="javax.validation.constraints.Min">
						                <element name="value">2</element>
						            </constraint>
						        </field>
						        <field name="driver">
						            <valid/>
						        </field>
						        <field name="partManufacturers">
						            <container-element-type type-argument-index="0">
						                <valid/>
						            </container-element-type>
						            <container-element-type type-argument-index="1">
						                <container-element-type>
						                    <valid/>
						                    <constraint annotation="javax.validation.constraints.NotNull"/>
						                </container-element-type>
						            </container-element-type>
						        </field>
						        <getter name="passedVehicleInspection" ignore-annotations="true">
						            <constraint annotation="javax.validation.constraints.AssertTrue">
						                <message>The car has to pass the vehicle inspection first</message>
						                <groups>
						                    <value>CarChecks</value>
						                </groups>
						                <element name="max">10</element>
						            </constraint>
						        </getter>
						    </bean>
						    <bean class="RentalCar" ignore-annotations="true">
						        <class ignore-annotations="true">
						            <group-sequence>
						                <value>RentalCar</value>
						                <value>CarChecks</value>
						            </group-sequence>
						        </class>
						    </bean>
						    <constraint-definition annotation="org.mycompany.CheckCase">
						        <validated-by include-existing-validators="false">
						            <value>org.mycompany.CheckCaseValidator</value>
						        </validated-by>
						    </constraint-definition>
						</constraint-mappings>

					Method constraints configured via XML
					
						<constraint-mappings
						        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
						        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
						            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
						        version="2.0">

						    <default-package>org.hibernate.validator.referenceguide.chapter08</default-package>

						    <bean class="RentalStation" ignore-annotations="true">
						        <constructor>
						            <return-value>
						                <constraint annotation="ValidRentalStation"/>
						            </return-value>
						        </constructor>

						        <constructor>
						            <parameter type="java.lang.String">
						                <constraint annotation="javax.validation.constraints.NotNull"/>
						            </parameter>
						        </constructor>

						        <method name="getCustomers">
						            <return-value>
						                <constraint annotation="javax.validation.constraints.NotNull"/>
						                <constraint annotation="javax.validation.constraints.Size">
						                    <element name="min">1</element>
						                </constraint>
						            </return-value>
						        </method>

						        <method name="rentCar">
						            <parameter type="Customer">
						                <constraint annotation="javax.validation.constraints.NotNull"/>
						            </parameter>
						            <parameter type="java.util.Date">
						                <constraint annotation="javax.validation.constraints.NotNull"/>
						                <constraint annotation="javax.validation.constraints.Future"/>
						            </parameter>
						            <parameter type="int">
						                <constraint annotation="javax.validation.constraints.Min">
						                    <element name="value">1</element>
						                </constraint>
						            </parameter>
						        </method>

						        <method name="addCars">
						            <parameter type="java.util.List">
						                <container-element-type>
						                    <valid/>
						                    <constraint annotation="javax.validation.constraints.NotNull"/>
						                </container-element-type>
						            </parameter>
						        </method>
						    </bean>

						    <bean class="Garage" ignore-annotations="true">
						        <method name="buildCar">
						            <parameter type="java.util.List"/>
						            <cross-parameter>
						                <constraint annotation="ELAssert">
						                    <element name="expression">...</element>
						                    <element name="validationAppliesTo">PARAMETERS</element>
						                </constraint>
						            </cross-parameter>
						        </method>
						        <method name="paintCar">
						            <parameter type="int"/>
						            <return-value>
						                <constraint annotation="ELAssert">
						                    <element name="expression">...</element>
						                    <element name="validationAppliesTo">RETURN_VALUE</element>
						                </constraint>
						            </return-value>
						        </method>
						    </bean>

						</constraint-mappings>	

			or 

				2. by passing it when bootstrapping a ValidatorFactory or Validator：

					ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();

					Validator validator = validatorFactory.usingContext()
					        .messageInterpolator( new MyMessageInterpolator() )
					        .traversableResolver( new MyTraversableResolver() )
					        .getValidator();

			4.2.1. ResourceBundleLocator
			
				Using a specific resource bundle:

					Validator validator = Validation.byDefaultProvider()
					        .configure()
					        .messageInterpolator(
					                new ResourceBundleMessageInterpolator(
					                        new PlatformResourceBundleLocator( "MyMessages" )
					                )
					        )
					        .buildValidatorFactory()
					        .getValidator();        

				Using AggregateResourceBundleLocator
				
					Validator validator = Validation.byDefaultProvider()
					        .configure()
					        .messageInterpolator(
					                new ResourceBundleMessageInterpolator(
					                        new AggregateResourceBundleLocator(
					                                Arrays.asList(
					                                        "MyMessages",
					                                        "MyOtherMessages"
					                                )
					                        )
					                )
					        )
					        .buildValidatorFactory()
					        .getValidator();	   

				
				i.e.：

					public class Car {

						@NotNull
						private String licensePlate;

						@Max(300)
						private int topSpeed = 400;

					}

					public class ResourceBundleLocatorTest {

						@Test
						public void messagesRetrievedFromSpecificBundle() {
							//tag::messagesRetrievedFromSpecificBundle[]
							Validator validator = Validation.byDefaultProvider()
									.configure()
									.messageInterpolator(
											new ResourceBundleMessageInterpolator(
													new PlatformResourceBundleLocator( "MyMessages" )
											)
									)
									.buildValidatorFactory()
									.getValidator();
							//end::messagesRetrievedFromSpecificBundle[]

							Set<ConstraintViolation<Car>> violations = validator.validateProperty(
									new Car(),
									"licensePlate"
							);
							assertEquals( 1, violations.size() );
							assertEquals( "null is not supported", violations.iterator().next().getMessage() );
						}

						@Test
						public void usingAggregateResourceBundleLocator() {
							//tag::usingAggregateResourceBundleLocator[]
							Validator validator = Validation.byDefaultProvider()
									.configure()
									.messageInterpolator(
											new ResourceBundleMessageInterpolator(
													new AggregateResourceBundleLocator(
															Arrays.asList(
																	"MyMessages",
																	"MyOtherMessages"
															)
													)
											)
									)
									.buildValidatorFactory()
									.getValidator();
							//end::usingAggregateResourceBundleLocator[]

							Set<ConstraintViolation<Car>> violations = validator.validateProperty(
									new Car(),
									"licensePlate"
							);
							assertEquals( 1, violations.size() );
							assertEquals( "null is not supported", violations.iterator().next().getMessage() );

							violations = validator.validateProperty( new Car(), "topSpeed" );
							assertEquals( 1, violations.size() );
							assertEquals( "too high", violations.iterator().next().getMessage() );
						}
					}

					scr\resources\MyMessages.properties

						javax.validation.constraints.NotNull.message=null is not supported

					src\resource\MyOtherMessages.properties
					
						javax.validation.constraints.Max.message=too high

	5. Grouping constraints

		5.1. Requesting groups

			Groups allow you to restrict the set of constraints applied during validation. 

			with javax.validation.groups.Default:

				public class Person {

					@NotNull
					private String name;

					public Person(String name) {
						this.name = name;
					}

					// getters and setters ...
				}


			with custom group DriverChecks:

				public class Driver extends Person {

					@Min(
							value = 18,
							message = "You have to be 18 to drive a car",
							groups = DriverChecks.class
					)
					public int age;

					@AssertTrue(
							message = "You first have to pass the driving test",
							groups = DriverChecks.class
					)
					public boolean hasDrivingLicense;

					public Driver(String name) {
						super( name );
					}

					public void passedDrivingTest(boolean b) {
						hasDrivingLicense = b;
					}

					public int getAge() {
						return age;
					}

					public void setAge(int age) {
						this.age = age;
					}
				}	

				public interface DriverChecks { }

			with custom group CarChecks:
			
				public class Car {
					@NotNull
					private String manufacturer;

					@NotNull
					@Size(min = 2, max = 14)
					private String licensePlate;

					@Min(2)
					private int seatCount;

					@AssertTrue(
							message = "The car has to pass the vehicle inspection first",
							groups = CarChecks.class
					)
					private boolean passedVehicleInspection;

					@Valid
					private Driver driver;

					public Car(String manufacturer, String licencePlate, int seatCount) {
						this.manufacturer = manufacturer;
						this.licensePlate = licencePlate;
						this.seatCount = seatCount;
					}

					public boolean isPassedVehicleInspection() {
						return passedVehicleInspection;
					}

					public void setPassedVehicleInspection(boolean passedVehicleInspection) {
						this.passedVehicleInspection = passedVehicleInspection;
					}

					public Driver getDriver() {
						return driver;
					}

					public void setDriver(Driver driver) {
						this.driver = driver;
					}

					// getters and setters ...
				}	

				public interface CarChecks {}

			group test：

				public class GroupTest {

					private static Validator validator;

					@BeforeClass
					public static void setUp() {
						ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void driveAway() {
						//tag::driveAway[]
						// create a car and check that everything is ok with it.
						Car car = new Car( "Morris", "DD-AB-123", 2 );
						Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );
						assertEquals( 0, constraintViolations.size() );

						// but has it passed the vehicle inspection?
						constraintViolations = validator.validate( car, CarChecks.class );
						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								"The car has to pass the vehicle inspection first",
								constraintViolations.iterator().next().getMessage()
						);

						// let's go to the vehicle inspection
						car.setPassedVehicleInspection( true );
						assertEquals( 0, validator.validate( car, CarChecks.class ).size() );

						// now let's add a driver. He is 18, but has not passed the driving test yet
						Driver john = new Driver( "John Doe" );
						john.setAge( 18 );
						car.setDriver( john );
						constraintViolations = validator.validate( car, DriverChecks.class );
						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								"You first have to pass the driving test",
								constraintViolations.iterator().next().getMessage()
						);

						// ok, John passes the test
						john.passedDrivingTest( true );
						assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

						// just checking that everything is in order now
						assertEquals(
								0, validator.validate(
								car,
								Default.class,
								CarChecks.class,
								DriverChecks.class
						).size()
						);
						//end::driveAway[]
					}
				}

		5.2. Group inheritance	

			public class SuperCar extends Car {

				@AssertTrue(
						message = "Race car must have a safety belt",
						groups = RaceCarChecks.class
				)
				private boolean safetyBelt;

				// getters and setters ...

				//end::include[]

				public SuperCar(String manufacturer, String licencePlate, int seatCount) {
					super( manufacturer, licencePlate, seatCount );
				}

				public boolean isSafetyBelt() {
					return safetyBelt;
				}

				public void setSafetyBelt(boolean safetyBelt) {
					this.safetyBelt = safetyBelt;
				}

			//tag::include[]
			}

			public interface RaceCarChecks extends Default {}

			public class GroupTest {
				@Test
				public void testGroupInheritance() {
					//tag::testGroupInheritance[]
					// create a supercar and check that it's valid as a generic Car
					SuperCar superCar = new SuperCar( "Morris", "DD-AB-123", 1  );
					assertEquals( "must be greater than or equal to 2", validator.validate( superCar ).iterator().next().getMessage() );

					// check that this supercar is valid as generic car and also as race car
					Set<ConstraintViolation<SuperCar>> constraintViolations = validator.validate( superCar, RaceCarChecks.class );

					assertThat( constraintViolations ).extracting( "message" ).containsOnly(
							"Race car must have a safety belt",
							"must be greater than or equal to 2"
					);
					//end::testGroupInheritance[]
				}

			}
			

		5.3. Defining group sequences	

			In order to implement such a validation order you just need to define an interface and annotate it with @GroupSequence, defining the order in which the groups have to be validated. If at least one constraint fails in a sequenced group, none of the constraints of the following groups in the sequence get validated.

			@GroupSequence({ Default.class, CarChecks.class, DriverChecks.class })
			public interface OrderedChecks {}	

			public class GroupTest {
				@Test
				public void testOrderedChecks() {
					//tag::testOrderedChecks[]
					Car car = new Car( "Morris", "DD-AB-123", 2 );
					car.setPassedVehicleInspection( true );

					Driver john = new Driver( "John Doe" );
					john.setAge( 18 );
					john.passedDrivingTest( true );
					car.setDriver( john );

					assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );
					//end::testOrderedChecks[]
				}
			}

		5.4. Redefining the default group sequence	

			5.4.1. @GroupSequence

				Besides defining group sequences, the @GroupSequence annotation also allows to redefine the default group for a given class. To do so, just add the @GroupSequence annotation to the class and specify the sequence of groups which substitute Default for this class within the annotation.

				@GroupSequence({ RentalChecks.class, CarChecks.class, RentalCar.class })
				public class RentalCar extends Car {
					@AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
					private boolean rented;

					public RentalCar(String manufacturer, String licencePlate, int seatCount) {
						super( manufacturer, licencePlate, seatCount );
					}

					public boolean isRented() {
						return rented;
					}

					public void setRented(boolean rented) {
						this.rented = rented;
					}
				}

				public interface RentalChecks {}

				public class GroupTest {

					@Test
					public void carIsRented() {
						//tag::carIsRented[]
						RentalCar rentalCar = new RentalCar( "Morris", "DD-AB-123", 2 );
						rentalCar.setPassedVehicleInspection( true );
						rentalCar.setRented( true );

						Set<ConstraintViolation<RentalCar>> constraintViolations = validator.validate( rentalCar );

						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								"Wrong message",
								"The car is currently rented out",
								constraintViolations.iterator().next().getMessage()
						);

						rentalCar.setRented( false );
						constraintViolations = validator.validate( rentalCar );

						assertEquals( 0, constraintViolations.size() );
						//end::carIsRented[]
					}
				}


			5.4.2. @GroupSequenceProvider

				public class RentalCarGroupSequenceProvider
						implements DefaultGroupSequenceProvider<RentalCar> {

					@Override
					public List<Class<?>> getValidationGroups(RentalCar car) {
						List<Class<?>> defaultGroupSequence = new ArrayList<Class<?>>();
						defaultGroupSequence.add( RentalCar.class );

						if ( car != null && !car.isRented() ) {
							defaultGroupSequence.add( CarChecks.class );
						}

						return defaultGroupSequence;
					}
				}

				@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)
				public class RentalCar extends Car {

					@AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
					private boolean rented;

					public RentalCar(String manufacturer, String licencePlate, int seatCount) {
						super( manufacturer, licencePlate, seatCount );
					}

					public boolean isRented() {
						return rented;
					}

					public void setRented(boolean rented) {
						this.rented = rented;
					}
				}


		5.5. Group conversion

			@ConvertGroup comes into play which allows you to use a different group than the originally requested one during cascaded validation.

			public class Driver {

				@NotNull
				private String name;

				@Min(
						value = 18,
						message = "You have to be 18 to drive a car",
						groups = DriverChecks.class
				)
				public int age;

				@AssertTrue(
						message = "You first have to pass the driving test",
						groups = DriverChecks.class
				)
				public boolean hasDrivingLicense;

				public Driver(String name) {
					this.name = name;
				}

				public void passedDrivingTest(boolean b) {
					hasDrivingLicense = b;
				}

				public int getAge() {
					return age;
				}

				public void setAge(int age) {
					this.age = age;
				}

				// getters and setters ...
			}

			public interface DriverChecks {}

			@GroupSequence({ CarChecks.class, Car.class })
			public class Car {

				@NotNull
				private String manufacturer;

				@NotNull
				@Size(min = 2, max = 14)
				private String licensePlate;

				@Min(2)
				private int seatCount;

				@AssertTrue(
						message = "The car has to pass the vehicle inspection first",
						groups = CarChecks.class
				)
				private boolean passedVehicleInspection;

				@Valid
				@ConvertGroup(from = Default.class, to = DriverChecks.class)
				private Driver driver;

				public Car(String manufacturer, String licencePlate, int seatCount) {
					this.manufacturer = manufacturer;
					this.licensePlate = licencePlate;
					this.seatCount = seatCount;
				}

				public boolean isPassedVehicleInspection() {
					return passedVehicleInspection;
				}

				public void setPassedVehicleInspection(boolean passedVehicleInspection) {
					this.passedVehicleInspection = passedVehicleInspection;
				}

				public Driver getDriver() {
					return driver;
				}

				public void setDriver(Driver driver) {
					this.driver = driver;
				}

				// getters and setters ...
			}

			public interface CarChecks {}

			public class GroupConversionTest {

				private static Validator validator;

				@BeforeClass
				public static void setUp() {
					ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
					validator = factory.getValidator();
				}

				@Test
				public void validateDriverChecksTogetherWithCarChecks() {
					//tag::validateDriverChecksTogetherWithCarChecks[]
					// create a car and validate. The Driver is still null and does not get validated
					Car car = new Car( "VW", "USD-123", 4 );
					car.setPassedVehicleInspection( true );
					Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );
					assertEquals( 0, constraintViolations.size() );

					// create a driver who has not passed the driving test
					Driver john = new Driver( "John Doe" );
					john.setAge( 18 );

					// now let's add a driver to the car
					car.setDriver( john );
					constraintViolations = validator.validate( car );
					assertEquals( 1, constraintViolations.size() );
					assertEquals(
							"The driver constraint should also be validated as part of the default group",
							constraintViolations.iterator().next().getMessage(),
							"You first have to pass the driving test"
					);
					//end::validateDriverChecksTogetherWithCarChecks[]
				}
			}

			tips： 正常情况下，此处调用@Valid进行校验时，仅校验group为Defualt的校验项，不会对其他group进行校验，但@Valid配合使用了
					@ConvertGroup(from = Default.class, to = DriverChecks.class)结果将Default转化为DriverCheck，所以此处校验了DriverChecks

	6. Creating custom constraints
	
		6.1 Creating a simple constraints

			To create a custom constraint, the following three steps are required:

				* Create a constraint annotation
				* Implement a validator
				* Define a default error message

			6.1.1. The constraint annotations	

				public enum CaseMode {
					UPPER,
					LOWER;
				}

				public class Car {

					@NotNull
					private String manufacturer;

					@NotNull
					@Size(min = 2, max = 14)
					@CheckCase(CaseMode.UPPER)
					private String licensePlate;

					@Min(2)
					private int seatCount;

					public Car(String manufacturer, String licencePlate, int seatCount) {
						this.manufacturer = manufacturer;
						this.licensePlate = licencePlate;
						this.seatCount = seatCount;
					}

					//getters and setters ...
				}

				@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE, TYPE_USE })
				@Retention(RUNTIME)
				@Constraint(validatedBy = CheckCaseValidator.class)
				@Documented
				@Repeatable(List.class)
				public @interface CheckCase {

					String message() default "{org.hibernate.validator.referenceguide.chapter06.CheckCase." +
							"message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };

					CaseMode value();

					@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE })
					@Retention(RUNTIME)
					@Documented
					@interface List {
						CheckCase[] value();
					}
				}

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUp() {
						ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void testCheckCaseConstraint() {
						//tag::testCheckCaseConstraint[]
						//invalid license plate
						Car car = new Car( "Morris", "dd-ab-123", 4 );
						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );
						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								"Case mode must be UPPER.",
								constraintViolations.iterator().next().getMessage()
						);

						//valid license plate
						car = new Car( "Morris", "DD-AB-123", 4 );

						constraintViolations = validator.validate( car );

						assertEquals( 0, constraintViolations.size() );
						//end::testCheckCaseConstraint[]
					}
				}

				tips:
					* an attribute message that returns the default key for creating error messages in case the constraint is violated
					* an attribute groups that allows the specification of validation groups, to which this constraint belongs. This must default to an empty array of type Class<?>.
					* an attribute payload that can be used by clients of the Bean Validation API to assign custom payload objects to a constraint. This attribute is not used by the API itself. 

						public class Severity {
							public interface Info extends Payload {
							}

							public interface Error extends Payload {
							}
						}

						public class ContactDetails {
							@NotNull(message = "Name is mandatory", payload = Severity.Error.class)
							private String name;

							@NotNull(message = "Phone number not specified, but not mandatory",
									payload = Severity.Info.class)
							private String phoneNumber;

							// ...
						}

						Now a client can after the validation of a ContactDetails instance access the severity of a constraint using ConstraintViolation.getConstraintDescriptor().getPayload() and adjust its behavior depending on the severity.

					* In addition, the constraint annotation is decorated with a couple of meta annotations:	

						* @Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE, TYPE_USE}): Defines the supported target element types for the constraint. 
						* @Retention(RUNTIME): Specifies, that annotations of this type will be available at runtime by the means of reflection
						* @Constraint(validatedBy = CheckCaseValidator.class): Marks the annotation type as constraint annotation and specifies the validator to be used to validate elements annotated with @CheckCase. If a constraint may be used on several data types, several validators may be specified, one for each data type.
						* @Documented: Says, that the use of @CheckCase will be contained in the JavaDoc of elements annotated with it
						* @Repeatable(List.class): Indicates that the annotation can be repeated several times at the same place, usually with a different configuration. List is the containing annotation type.

			6.1.2. The constraint validator						

				public class CheckCaseValidator implements ConstraintValidator<CheckCase, String> {

					private CaseMode caseMode;

					@Override
					public void initialize(CheckCase constraintAnnotation) {
						this.caseMode = constraintAnnotation.value();
					}

					@Override
					public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
						if ( object == null ) {
							return true;
						}

						if ( caseMode == CaseMode.UPPER ) {
							return object.equals( object.toUpperCase() );
						}
						else {
							return object.equals( object.toLowerCase() );
						}
					}
				}

				6.1.2.1. The ConstraintValidatorContext

					public class CheckCaseValidator implements ConstraintValidator<CheckCase, String> {

						private CaseMode caseMode;

						@Override
						public void initialize(CheckCase constraintAnnotation) {
							this.caseMode = constraintAnnotation.value();
						}

						@Override
						public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
							if ( object == null ) {
								return true;
							}

							boolean isValid;
							if ( caseMode == CaseMode.UPPER ) {
								isValid = object.equals( object.toUpperCase() );
							}
							else {
								isValid = object.equals( object.toLowerCase() );
							}

							if ( !isValid ) {
								constraintContext.disableDefaultConstraintViolation();
								constraintContext.buildConstraintViolationWithTemplate(
										"{org.hibernate.validator.referenceguide.chapter06." +
										"constraintvalidatorcontext.CheckCase.message}"
								)
								.addConstraintViolation();
							}

							return isValid;
						}
					}

				6.1.2.2. The HibernateConstraintValidator extension

					@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
					@Retention(RUNTIME)
					@Repeatable(List.class)
					@Documented
					@Constraint(validatedBy = { })
					public @interface MyFuture {

						String message() default "{org.hibernate.validator.referenceguide.chapter06.MyFuture." +
								"message}";

						Class<?>[] groups() default { };

						Class<? extends Payload>[] payload() default { };

						boolean orPresent() default false;

						@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
						@Retention(RUNTIME)
						@Documented
						@interface List {

							MyFuture[] value();
						}
					}

					public class MyFutureValidator implements HibernateConstraintValidator<MyFuture, Instant> {

						private Clock clock;

						private boolean orPresent;

						@Override
						public void initialize(ConstraintDescriptor<MyFuture> constraintDescriptor,
								HibernateConstraintValidatorInitializationContext initializationContext) {
							this.orPresent = constraintDescriptor.getAnnotation().orPresent();
							this.clock = initializationContext.getClockProvider().getClock();
						}

						@Override
						public boolean isValid(Instant instant, ConstraintValidatorContext constraintContext) {
							//...

							return false;
						}
					}

				6.1.2.3. Passing a payload to the constraint validator

					@Target({ METHOD, FIELD, ANNOTATION_TYPE, TYPE_USE })
					@Retention(RUNTIME)
					@Constraint(validatedBy = ZipCodeValidator.class)
					@Documented
					public @interface ZipCode {

						String message() default "{org.hibernate.validator.referenceguide.chapter06.constraintvalidatorpayload.ZipCode.message}";

						Class<?>[] groups() default { };

						Class<? extends Payload>[] payload() default { };
					}

					public class ZipCodeValidator implements ConstraintValidator<ZipCode, String> {

						public String countryCode;

						@Override
						public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
							if ( object == null ) {
								return true;
							}

							boolean isValid = false;

							String countryCode = constraintContext
									.unwrap( HibernateConstraintValidatorContext.class )
									.getConstraintValidatorPayload( String.class );

							if ( "US".equals( countryCode ) ) {
								// checks specific to the United States
							}
							else if ( "FR".equals( countryCode ) ) {
								// checks specific to France
							}
							else {
								// ...
							}

							return isValid;
						}
					}

					public class ConstraintValidatorPayloadTest {

						@Test
						public void setConstraintValidatorPayloadDuringValidatorFactoryInitialization() {
							//tag::setConstraintValidatorPayloadDuringValidatorFactoryInitialization[]
							ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
									.configure()
									.constraintValidatorPayload( "US" )
									.buildValidatorFactory();

							Validator validator = validatorFactory.getValidator();
							//end::setConstraintValidatorPayloadDuringValidatorFactoryInitialization[]
						}

						@Test
						public void setConstraintValidatorPayloadInValidatorContext() {
							//tag::setConstraintValidatorPayloadInValidatorContext[]
							HibernateValidatorFactory hibernateValidatorFactory = Validation.byDefaultProvider()
									.configure()
									.buildValidatorFactory()
									.unwrap( HibernateValidatorFactory.class );

							Validator validator = hibernateValidatorFactory.usingContext()
									.constraintValidatorPayload( "US" )
									.getValidator();

							// [...] US specific validation checks

							validator = hibernateValidatorFactory.usingContext()
									.constraintValidatorPayload( "FR" )
									.getValidator();

							// [...] France specific validation checks

							//end::setConstraintValidatorPayloadInValidatorContext[]
						}
					}

					tips：
						* It is important to note that the constraint validator payload is different from the dynamic payload you can include in the constraint violation raised.
						* The whole purpose of this constraint validator payload is to be used to condition the behavior of your constraint validators. It is not included in the constraint violations, unless a specific ConstraintValidator implementation passes on the payload to emitted constraint violations by using the constraint violation dynamic payload mechanism.

			6.1.3. The error message

				ValidationMessages.properties：

					org.hibernate.validator.referenceguide.chapter06.CheckCase.message=Case mode must be {value}.

			6.1.4. Using the constraint

				示例见参见6.1.1

		6.2. Class-level constraints

				@ValidPassengerCount(message = "There must be not more passengers than seats.")
				public class Car {

					private int seatCount;

					private List<Person> passengers;

					public Car(int seatCount, List<Person> passengers) {
						this.seatCount = seatCount;
						this.passengers = passengers;
					}

					public int getSeatCount() {
						return seatCount;
					}

					public List<Person> getPassengers() {
						return passengers;
					}
				}

				public class Person {

					private String name;

					public Person(String name) {
						this.name = name;
					}
				}

				@Target({ TYPE, ANNOTATION_TYPE })
				@Retention(RUNTIME)
				@Constraint(validatedBy = { ValidPassengerCountValidator.class })
				@Documented
				public @interface ValidPassengerCount {

					String message() default "{org.hibernate.validator.referenceguide.chapter06.classlevel." +
							"ValidPassengerCount.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };
				}

				public class ValidPassengerCountValidator
						implements ConstraintValidator<ValidPassengerCount, Car> {

					@Override
					public void initialize(ValidPassengerCount constraintAnnotation) {
					}

					@Override
					public boolean isValid(Car car, ConstraintValidatorContext context) {
						if ( car == null ) {
							return true;
						}

						return car.getPassengers().size() <= car.getSeatCount();
					}
				}

				public class ClassLevelConstraintTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void testClassLevelConstraint() {
						Car car = new Car(
								2,
								Arrays.asList(
										new Person( "Alice" ),
										new Person( "Bob" ),
										new Person( "Bill" )
								)
						);

						Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								"There must be not more passengers than seats.",
								constraintViolations.iterator().next().getMessage()
						);
					}
				}

			6.2.1. Custom property paths

				public class ValidPassengerCountValidator
						implements ConstraintValidator<ValidPassengerCount, Car> {

					@Override
					public void initialize(ValidPassengerCount constraintAnnotation) {
					}

					@Override
					public boolean isValid(Car car, ConstraintValidatorContext constraintValidatorContext) {
						if ( car == null ) {
							return true;
						}

						boolean isValid = car.getPassengers().size() <= car.getSeatCount();

						if ( !isValid ) {
							constraintValidatorContext.disableDefaultConstraintViolation();
							constraintValidatorContext
									.buildConstraintViolationWithTemplate( "{my.custom.template}" )
									.addPropertyNode( "passengers" ).addConstraintViolation();
						}

						return isValid;
					}
				}

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUp() {
						ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void morePassengersThanSeats() {
						Car car = new Car( 2, Arrays.asList( "Bob", "Alice", "Bill" ) );

						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );

						assertEquals( 1, constraintViolations.size() );

						ConstraintViolation<Car> violation = constraintViolations.iterator().next();
						assertEquals( "{my.custom.template}", violation.getMessage() );
						assertEquals( "passengers", violation.getPropertyPath().iterator().next().getName() );
					}
				}

		6.3. Cross-parameter constraints

			Bean Validation distinguishes between two different kinds of constraints.

				@Constraint(validatedBy = ConsistentDateParametersValidator.class)
				@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
				@Retention(RUNTIME)
				@Documented
				public @interface ConsistentDateParameters {

					String message() default "{org.hibernate.validator.referenceguide.chapter04." +
							"crossparameter.ConsistentDateParameters.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };
				}

				@SupportedValidationTarget(ValidationTarget.PARAMETERS)
				public class ConsistentDateParametersValidator implements
						ConstraintValidator<ConsistentDateParameters, Object[]> {

					@Override
					public void initialize(ConsistentDateParameters constraintAnnotation) {
					}

					@Override
					public boolean isValid(Object[] value, ConstraintValidatorContext context) {
						if ( value.length != 2 ) {
							throw new IllegalArgumentException( "Illegal method signature" );
						}

						//leave null-checking to @NotNull on individual parameters
						if ( value[0] == null || value[1] == null ) {
							return true;
						}

						if ( !( value[0] instanceof Date ) || !( value[1] instanceof Date ) ) {
							throw new IllegalArgumentException(
									"Illegal method signature, expected two " +
											"parameters of type Date."
							);
						}

						return ( (Date) value[0] ).before( (Date) value[1] );
					}
				}

				public class ConsistentDateParametersTest {

					private static ExecutableValidator executableValidator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
						executableValidator = factory.getValidator().forExecutables();
					}

					@Test
					public void testConsistentDateParametersConstraint() throws Exception {
						CalendarService object = new CalendarService();
						Method method = CalendarService.class.getMethod( "createCalendarEvent", Date.class, Date.class );

						Calendar start = Calendar.getInstance();
						start.set( 2013, 5, 10 );
						Calendar end = Calendar.getInstance();
						end.set( 2013, 5, 9 );
						Object[] parameterValues = new Object[] { start.getTime(), end.getTime() };
						Set<ConstraintViolation<CalendarService>> constraintViolations = executableValidator.validateParameters(
								object,
								method,
								parameterValues
						);

						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								ConsistentDateParameters.class,
								constraintViolations.iterator().next().getConstraintDescriptor().getAnnotation().annotationType()
						);
					}

					private static class CalendarService {

						@ConsistentDateParameters
						public void createCalendarEvent(@NotNull Date start, @NotNull Date end) {
							//...
						}
					}
				}

				@Constraint(validatedBy = {
						ScriptAssertObjectValidator.class,
						ScriptAssertParametersValidator.class
				})
				@Target({ TYPE, FIELD, PARAMETER, METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
				@Retention(RUNTIME)
				@Documented
				public @interface ScriptAssert {

					String message() default "{org.hibernate.validator.referenceguide.chapter04." +
							"crossparameter.ScriptAssert.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };

					String script();

					ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
				}

				public class ScriptAssertObjectValidator implements
						ConstraintValidator<ScriptAssert, Object> {

					@Override
					public void initialize(ScriptAssert constraintAnnotation) {
					}

					@Override
					public boolean isValid(Object value, ConstraintValidatorContext context) {
						return false;
					}
				}

				@SupportedValidationTarget(ValidationTarget.PARAMETERS)
				public class ScriptAssertParametersValidator implements
						ConstraintValidator<ScriptAssert, Object[]> {

					@Override
					public void initialize(ScriptAssert constraintAnnotation) {
					}

					@Override
					public boolean isValid(Object[] value, ConstraintValidatorContext context) {
						return false;
					}
				}

				public class ScriptAssertTest {

					//tag::buildCar[]
					@ScriptAssert(script = "arg1.size() <= arg0", validationAppliesTo = ConstraintTarget.PARAMETERS)
					public Car buildCar(int seatCount, List<Passenger> passengers) {
						//...
						return null;
					}
					//end::buildCar[]

					private static class Car {
					}

					private static class Passenger {
					}
				}

		6.4. Constraint composition

			To create a composed constraint, simply annotate the constraint declaration with its comprising constraints. If the composed constraint itself requires a validator, this validator is to be specified within the @Constraint annotation. For composed constraints which don’t need an additional validator such as @ValidLicensePlate, just set validatedBy() to an empty array.

				@NotNull
				@Size(min = 2, max = 14)
				@CheckCase(CaseMode.UPPER)
				@Target({ METHOD, FIELD, ANNOTATION_TYPE, TYPE_USE })
				@Retention(RUNTIME)
				@Constraint(validatedBy = { })
				@Documented
				public @interface ValidLicensePlate {

					String message() default "{org.hibernate.validator.referenceguide.chapter06." +
							"constraintcomposition.ValidLicensePlate.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };
				}

			The set of ConstraintViolations retrieved when validating a Car instance will contain an entry for each violated composing constraint of the @ValidLicensePlate constraint. If you rather prefer a single ConstraintViolation in case any of the composing constraints is violated, the @ReportAsSingleViolation meta constraint can be used as follows:

				@ReportAsSingleViolation
				public @interface ValidLicensePlate {

					String message() default "{org.hibernate.validator.referenceguide.chapter06." +
							"constraintcomposition.reportassingle.ValidLicensePlate.message}";

					Class<?>[] groups() default { };

					Class<? extends Payload>[] payload() default { };
				}

	7. Value extraction

		7.1. Built-in value extractors

			Built-in value extractors are present for all the following container types:

				* java.util.Iterable;
				* java.util.List;
				* java.util.Map: for keys and values;
				* java.util.Optional, java.util.OptionalInt, java.util.OptionalLong and java.util.OptionalDouble;
				* JavaFX's ObservableValue (see Section 7.4, “JavaFX value extractors” for more details).
		
		7.2. Implementing a ValueExtractor

			public class OptionalValueExtractor
					implements ValueExtractor<Optional<@ExtractedValue ?>> {

				@Override
				public void extractValues(Optional<?> originalValue, ValueReceiver receiver) {
					receiver.value( null, originalValue.orNull() );
				}
			}

			public class MultimapKeyValueExtractor
					implements ValueExtractor<Multimap<@ExtractedValue ?, ?>> {

				@Override
				public void extractValues(Multimap<?, ?> originalValue, ValueReceiver receiver) {
					for ( Object key : originalValue.keySet() ) {
						receiver.keyedValue( "<multimap key>", key, key );
					}
				}
			}

			public class MultimapValueValueExtractor
					implements ValueExtractor<Multimap<?, @ExtractedValue ?>> {

				@Override
				public void extractValues(Multimap<?, ?> originalValue, ValueReceiver receiver) {
					for ( Entry<?, ?> entry : originalValue.entries() ) {
						receiver.keyedValue( "<multimap value>", entry.getKey(), entry.getValue() );
					}
				}
			}

			tips： 
				Depending on your container type, you should choose the ValueReceiver method fitting the best:
					* value()
						for a simple wrapping container - it is used for Optionals
					* iterableValue()
						for an iterable container - it is used for Sets
					* indexedValue()
						for a container containing indexed values - it is used for Lists
					* keyedValue()
						for a container containing keyed values - it is used for Maps. It is used for both the keys and the values. In the case of keys, the key is also passed as the validated value.

		7.3. Non generic containers

			public class OptionalIntValueExtractor
					implements ValueExtractor<@ExtractedValue(type = Integer.class) OptionalInt> {

				@Override
				public void extractValues(OptionalInt originalValue, ValueReceiver receiver) {
					receiver.value( null, originalValue.isPresent() ? originalValue.getAsInt() : null );
				}
			}

			@UnwrapByDefault
			public class UnwrapByDefaultOptionalIntValueExtractor
					implements ValueExtractor<@ExtractedValue(type = Integer.class) OptionalInt> {

				@Override
				public void extractValues(OptionalInt originalValue, ValueReceiver receiver) {
					receiver.value( null, originalValue.isPresent() ? originalValue.getAsInt() : null );
				}
			}

		7.4. JavaFX value extractors

		7.5. Registering a ValueExtractor	

			Hibernate Validator does not detect automatically the value extractors in the classpath so they have to be registered.
			There are several ways to register value extractors (in increasing order of priority):

				* Provided by the validation engine itself
				* Via the Java service loader mechanism
				* In the META-INF/validation.xml file
				* By calling Configuration#addValueExtractor(ValueExtractor<?>)
				* By invoking ValidatorContext#addValueExtractor(ValueExtractor<?>)

		7.6. Resolution algorithms		

			One important thing to have in mind is that:
				for container element constraints, the declared type is used to resolve the value extractors;
				for cascaded validation, it is the runtime type.

		@SuppressWarnings({ "restriction", "unused" })
		public class Container {

			//tag::multimapValues[]
			private Multimap<String, @NotBlank String> map1;
			//end::multimapValues[]

			//tag::multimapKeysAndValues[]
			private Multimap<@NotBlank String, @NotBlank String> map2;
			//end::multimapKeysAndValues[]

			//tag::optionalIntUnwrap[]
			@Min(value = 5, payload = Unwrapping.Unwrap.class)
			private OptionalInt optionalInt1;
			//end::optionalIntUnwrap[]

			//tag::optionalInt[]
			@Min(5)
			private OptionalInt optionalInt2;
			//end::optionalInt[]

			//tag::optionalIntSkip[]
			@NotNull(payload = Unwrapping.Skip.class)
			@Min(5)
			private OptionalInt optionalInt3;
			//end::optionalIntSkip[]

			//tag::stringProperty[]
			@NotBlank
			private StringProperty stringProperty;
			//end::stringProperty[]

			//tag::longProperty[]
			@Min(5)
			private LongProperty longProperty;
			//end::longProperty[]

			//tag::listProperty[]
			@Size(min = 1)
			private ReadOnlyListProperty<@NotBlank String> listProperty;
			//end::listProperty[]
		}	

	8. Configuring via XML

		8.1. Configuring the validator factory in validation.xml

			<validation-config
			        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
			        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration
			            http://xmlns.jcp.org/xml/ns/validation/configuration/validation-configuration-2.0.xsd"
			        version="2.0">

			    <default-provider>com.acme.ValidationProvider</default-provider>

			    <message-interpolator>com.acme.MessageInterpolator</message-interpolator>
			    <traversable-resolver>com.acme.TraversableResolver</traversable-resolver>
			    <constraint-validator-factory>
			        com.acme.ConstraintValidatorFactory
			    </constraint-validator-factory>
			    <parameter-name-provider>com.acme.ParameterNameProvider</parameter-name-provider>
			    <clock-provider>com.acme.ClockProvider</clock-provider>

			    <value-extractor>com.acme.ContainerValueExtractor</value-extractor>

			    <executable-validation enabled="true">
			        <default-validated-executable-types>
			            <executable-type>CONSTRUCTORS</executable-type>
			            <executable-type>NON_GETTER_METHODS</executable-type>
			            <executable-type>GETTER_METHODS</executable-type>
			        </default-validated-executable-types>
			    </executable-validation>

			    <constraint-mapping>META-INF/validation/constraints-car.xml</constraint-mapping>

			    <property name="hibernate.validator.fail_fast">false</property>
			</validation-config>

			tips: There must only be one file named META-INF/validation.xml on the classpath. If more than one is found an exception is thrown.

		8.2. Mapping constraints via constraint-mappings
		
			Note that these mapping files are only processed if listed via constraint-mapping in validation.xml.

			* Bean constraints configured via XML	

				<constraint-mappings
				        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
				        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
				            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
				        version="2.0">

				    <default-package>org.hibernate.validator.referenceguide.chapter05</default-package>
				    <bean class="Car" ignore-annotations="true">
				        <field name="manufacturer">
				            <constraint annotation="javax.validation.constraints.NotNull"/>
				        </field>
				        <field name="licensePlate">
				            <constraint annotation="javax.validation.constraints.NotNull"/>
				        </field>
				        <field name="seatCount">
				            <constraint annotation="javax.validation.constraints.Min">
				                <element name="value">2</element>
				            </constraint>
				        </field>
				        <field name="driver">
				            <valid/>
				        </field>
				        <field name="partManufacturers">
				            <container-element-type type-argument-index="0">
				                <valid/>
				            </container-element-type>
				            <container-element-type type-argument-index="1">
				                <container-element-type>
				                    <valid/>
				                    <constraint annotation="javax.validation.constraints.NotNull"/>
				                </container-element-type>
				            </container-element-type>
				        </field>
				        <getter name="passedVehicleInspection" ignore-annotations="true">
				            <constraint annotation="javax.validation.constraints.AssertTrue">
				                <message>The car has to pass the vehicle inspection first</message>
				                <groups>
				                    <value>CarChecks</value>
				                </groups>
				                <element name="max">10</element>
				            </constraint>
				        </getter>
				    </bean>
				    <bean class="RentalCar" ignore-annotations="true">
				        <class ignore-annotations="true">
				            <group-sequence>
				                <value>RentalCar</value>
				                <value>CarChecks</value>
				            </group-sequence>
				        </class>
				    </bean>
				    <constraint-definition annotation="org.mycompany.CheckCase">
				        <validated-by include-existing-validators="false">
				            <value>org.mycompany.CheckCaseValidator</value>
				        </validated-by>
				    </constraint-definition>
				</constraint-mappings>

			* Method constraints configured via XML

				<constraint-mappings
				        xmlns="http://xmlns.jcp.org/xml/ns/validation/mapping"
				        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/mapping
				            http://xmlns.jcp.org/xml/ns/validation/mapping/validation-mapping-2.0.xsd"
				        version="2.0">

				    <default-package>org.hibernate.validator.referenceguide.chapter08</default-package>

				    <bean class="RentalStation" ignore-annotations="true">
				        <constructor>
				            <return-value>
				                <constraint annotation="ValidRentalStation"/>
				            </return-value>
				        </constructor>

				        <constructor>
				            <parameter type="java.lang.String">
				                <constraint annotation="javax.validation.constraints.NotNull"/>
				            </parameter>
				        </constructor>

				        <method name="getCustomers">
				            <return-value>
				                <constraint annotation="javax.validation.constraints.NotNull"/>
				                <constraint annotation="javax.validation.constraints.Size">
				                    <element name="min">1</element>
				                </constraint>
				            </return-value>
				        </method>

				        <method name="rentCar">
				            <parameter type="Customer">
				                <constraint annotation="javax.validation.constraints.NotNull"/>
				            </parameter>
				            <parameter type="java.util.Date">
				                <constraint annotation="javax.validation.constraints.NotNull"/>
				                <constraint annotation="javax.validation.constraints.Future"/>
				            </parameter>
				            <parameter type="int">
				                <constraint annotation="javax.validation.constraints.Min">
				                    <element name="value">1</element>
				                </constraint>
				            </parameter>
				        </method>

				        <method name="addCars">
				            <parameter type="java.util.List">
				                <container-element-type>
				                    <valid/>
				                    <constraint annotation="javax.validation.constraints.NotNull"/>
				                </container-element-type>
				            </parameter>
				        </method>
				    </bean>

				    <bean class="Garage" ignore-annotations="true">
				        <method name="buildCar">
				            <parameter type="java.util.List"/>
				            <cross-parameter>
				                <constraint annotation="ELAssert">
				                    <element name="expression">...</element>
				                    <element name="validationAppliesTo">PARAMETERS</element>
				                </constraint>
				            </cross-parameter>
				        </method>
				        <method name="paintCar">
				            <parameter type="int"/>
				            <return-value>
				                <constraint annotation="ELAssert">
				                    <element name="expression">...</element>
				                    <element name="validationAppliesTo">RETURN_VALUE</element>
				                </constraint>
				            </return-value>
				        </method>
				    </bean>

				</constraint-mappings>

			相当于注解式的：

				public class RentalStation {

					@ValidRentalStation
					public RentalStation() {
					}

					@NotNull
					public RentalStation(String name) {
					}

					@NotNull
					@Size(min = 1)
					public List<Customer> getCustomers() {
						return null;
					}


					public void rentCar(@NotNull Customer customer, 
										@NotNull @Future Date startDate, 
										@Min(1) int durationInDays) {
					}

					public void addCars(List<@Valid @NotNull Car> cars) {
					}
				}

				public class Garage {

					@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.PARAMETERS)
					public Car buildCar(List<Part> parts) {
						//...
						return null;
					}

					@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.RETURN_VALUE)
					public Car paintCar(int color) {
						//...
						return null;
					}
				}


			Using XML to register a regular expression based constraint definition for @URL
			
				<constraint-definition annotation="org.hibernate.validator.constraints.URL">
				  <validated-by include-existing-validators="false">
				    <value>org.hibernate.validator.constraintvalidators.RegexpURLValidator</value>
				  </validated-by>
				</constraint-definition>	

		TEST：
			
			public class XMLConfigurationTest {
				private static Validator validator;

				@BeforeClass
				public static void setUpValidator() {
					Configuration<?> configuration = Validation.byDefaultProvider().configure();
					configuration.addMapping( XMLConfigurationTest.class.getResourceAsStream( "rental-station-mapping.xml" ) );
					ValidatorFactory factory = configuration.buildValidatorFactory();
					validator = factory.getValidator();
				}

				@Test
				public void testXMLConstraintsApplied() {
					BeanDescriptor beanDescriptor = validator.getConstraintsForClass( RentalStation.class );

					assertTrue( beanDescriptor.isBeanConstrained() );

					ConstructorDescriptor constructorDescriptor = beanDescriptor.getConstraintsForConstructor();
					ReturnValueDescriptor returnValueDescriptor = constructorDescriptor.getReturnValueDescriptor();
					Set<ConstraintDescriptor<?>> constraintDescriptors = returnValueDescriptor.getConstraintDescriptors();
					assertCorrectConstraintTypes( constraintDescriptors, ValidRentalStation.class );

					constructorDescriptor = beanDescriptor.getConstraintsForConstructor( String.class );
					List<ParameterDescriptor> parameterDescriptors = constructorDescriptor.getParameterDescriptors();
					constraintDescriptors = parameterDescriptors.get( 0 ).getConstraintDescriptors();
					assertCorrectConstraintTypes( constraintDescriptors, NotNull.class );

					MethodDescriptor methodDescriptor = beanDescriptor.getConstraintsForMethod( "getCustomers" );
					returnValueDescriptor = methodDescriptor.getReturnValueDescriptor();
					constraintDescriptors = returnValueDescriptor.getConstraintDescriptors();
					assertCorrectConstraintTypes( constraintDescriptors, NotNull.class, Size.class );

					methodDescriptor = beanDescriptor.getConstraintsForMethod( "rentCar", Customer.class, Date.class, int.class );
					parameterDescriptors = methodDescriptor.getParameterDescriptors();

					constraintDescriptors = parameterDescriptors.get( 0 ).getConstraintDescriptors();
					assertCorrectConstraintTypes( constraintDescriptors, NotNull.class );

					constraintDescriptors = parameterDescriptors.get( 1 ).getConstraintDescriptors();
					assertCorrectConstraintTypes( constraintDescriptors, NotNull.class, Future.class );

					constraintDescriptors = parameterDescriptors.get( 2 ).getConstraintDescriptors();
					assertCorrectConstraintTypes( constraintDescriptors, Min.class );
				}

				@Test
				public void testXMLCrossParameterConstraints() {
					BeanDescriptor beanDescriptor = validator.getConstraintsForClass( Garage.class );

					MethodDescriptor methodDescriptor = beanDescriptor.getConstraintsForMethod( "buildCar", java.util.List.class );
					CrossParameterDescriptor crossParameterDescriptor = methodDescriptor.getCrossParameterDescriptor();
					Set<ConstraintDescriptor<?>> constraintDescriptors = crossParameterDescriptor.getConstraintDescriptors();
					assertCorrectConstraintTypes( constraintDescriptors, ELAssert.class );

					methodDescriptor = beanDescriptor.getConstraintsForMethod( "paintCar", int.class );
					ReturnValueDescriptor returnValueDescriptor = methodDescriptor.getReturnValueDescriptor();
					constraintDescriptors = returnValueDescriptor.getConstraintDescriptors();
					assertCorrectConstraintTypes( constraintDescriptors, ELAssert.class );
				}

				private void assertCorrectConstraintTypes( Set<ConstraintDescriptor<?>> constraintDescriptors,
														  Class<?>... constraints) {
					List<Class<?>> constraintAnnotations = new ArrayList<Class<?>>();
					constraintAnnotations.addAll( Arrays.asList( constraints ) );
					for ( ConstraintDescriptor descriptor : constraintDescriptors ) {
						Class<?> annotationType = descriptor.getAnnotation().annotationType();
						if ( constraintAnnotations.contains( annotationType ) ) {
							constraintAnnotations.remove( annotationType );
						}
						else {
							fail( "found constraint type " + annotationType + " which was not expected" );
						}
					}

					if ( !constraintAnnotations.isEmpty() ) {
						fail( "not all expected constraint types were found" );
					}
				}
			}

	9. Bootstrapping			

		9.1. Retrieving ValidatorFactory and Validator	

			* Bootstrapping default ValidatorFactory and Validator

				ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();
				Validator validator = validatorFactory.getValidator();

			* Bootstrapping ValidatorFactory and Validator using a specific provider	

				ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
				        .configure()
				        .buildValidatorFactory();
				Validator validator = validatorFactory.getValidator();

			* Retrieving the default ValidatorFactory for configuration
				ValidatorFactory validatorFactory = Validation.byDefaultProvider()
				        .configure()
				        .buildValidatorFactory();
				Validator validator = validatorFactory.getValidator();	

			tips:
				If a ValidatorFactory instance is no longer in use, it should be disposed by calling ValidatorFactory#close(). This will free any resources possibly allocated by the factory.	

			9.1.1. ValidationProviderResolver		

				* Using a custom ValidationProviderResolver

				定义：

					public class OsgiServiceDiscoverer implements ValidationProviderResolver {

					    @Override
					    public List<ValidationProvider<?>> getValidationProviders() {
					        //...
					        return null;
					    }
					}		

				配置：

					ValidatorFactory validatorFactory = Validation.byDefaultProvider()
					        .providerResolver( new OsgiServiceDiscoverer() )
					        .configure()
					        .buildValidatorFactory();
					Validator validator = validatorFactory.getValidator();

		9.2. Configuring a ValidatorFactory

			By default, validator factories retrieved from Validation and any validators they create are configured as per the XML descriptor META-INF/validation.xml, if present.

			If you want to disable the XML based configuration, you can do so by invoking Configuration#ignoreXmlConfiguration().

			The different values of the XML configuration can be accessed via Configuration#getBootstrapConfiguration(). 

			9.2.1. MessageInterpolator

				Message interpolators are used by the validation engine to create user readable error messages from constraint message descriptors.

				定义：

					public class MyMessageInterpolator implements MessageInterpolator {

						@Override
						public String interpolate(String messageTemplate, Context context) {
							//...
							return null;
						}

						@Override
						public String interpolate(String messageTemplate, Context context, Locale locale) {
							//...
							return null;
						}
					}

				配置：

					ValidatorFactory validatorFactory = Validation.byDefaultProvider()
					        .configure()
					        .messageInterpolator( new MyMessageInterpolator() )
					        .buildValidatorFactory();
					Validator validator = validatorFactory.getValidator();

			9.2.2. TraversableResolver		

				定义：

					public class MyTraversableResolver implements TraversableResolver {

					    @Override
					    public boolean isReachable(
					            Object traversableObject,
					            Node traversableProperty,
					            Class<?> rootBeanType,
					            Path pathToTraversableObject,
					            ElementType elementType) {
					        //...
					        return false;
					    }

					    @Override
					    public boolean isCascadable(
					            Object traversableObject,
					            Node traversableProperty,
					            Class<?> rootBeanType,
					            Path pathToTraversableObject,
					            ElementType elementType) {
					        //...
					        return false;
					    }
					}

				配置：

					ValidatorFactory validatorFactory = Validation.byDefaultProvider()
					        .configure()
					        .traversableResolver( new MyTraversableResolver() )
					        .buildValidatorFactory();
					Validator validator = validatorFactory.getValidator();

				缓存关闭：	

					By default, the traversable resolver calls are cached per validation call. This is especially important in a JPA environment where calling isReachable() has a significant cost.
					This caching adds some overhead. In the case your custom traversable resolver is very fast, it might be better to consider turning off the cache.	

					1. Disabling the TraversableResolver result cache via the XML configuration

						<?xml version="1.0" encoding="UTF-8"?>
						<validation-config
						        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
						        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
						        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration validation-configuration-2.0.xsd"
						        version="2.0">
						    <default-provider>org.hibernate.validator.HibernateValidator</default-provider>

						    <property name="hibernate.validator.enable_traversable_resolver_result_cache">false</property>
						</validation-config>

					2. Disabling the TraversableResolver result cache via the programmatic API

						ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
						        .configure()
						        .traversableResolver( new MyFastTraversableResolver() )
						        .enableTraversableResolverResultCache( false )
						        .buildValidatorFactory();
						Validator validator = validatorFactory.getValidator();

			9.2.3. ConstraintValidatorFactory						

				To configure a custom constraint validator factory call Configuration#constraintValidatorFactory()

				* Using a custom ConstraintValidatorFactory

					定义：

						public class MyConstraintValidatorFactory implements ConstraintValidatorFactory {

						    @Override
						    public <T extends ConstraintValidator<?, ?>> T getInstance(Class<T> key) {
						        //...
						        return null;
						    }

						    @Override
						    public void releaseInstance(ConstraintValidator<?, ?> instance) {
						        //...
						    }
						}

					配置：

						ValidatorFactory validatorFactory = Validation.byDefaultProvider()
						        .configure()
						        .constraintValidatorFactory( new MyConstraintValidatorFactory() )
						        .buildValidatorFactory();
						Validator validator = validatorFactory.getValidator();

			9.2.4. ParameterNameProvider

				* Using a custom ParameterNameProvider

					定义：

						public class MyParameterNameProvider implements ParameterNameProvider {

						    @Override
						    public List<String> getParameterNames(Constructor<?> constructor) {
						        //...
						        return null;
						    }

						    @Override
						    public List<String> getParameterNames(Method method) {
						        //...
						        return null;
						    }
						}

					配置：

						ValidatorFactory validatorFactory = Validation.byDefaultProvider()
						        .configure()
						        .parameterNameProvider( new MyParameterNameProvider() )
						        .buildValidatorFactory();
						Validator validator = validatorFactory.getValidator();

			9.2.5. ClockProvider and temporal validation tolerance

				* Using a custom ClockProvider

					定义：

						public class FixedClockProvider implements ClockProvider {

						    private Clock clock;

						    public FixedClockProvider(ZonedDateTime dateTime) {
						        clock = Clock.fixed( dateTime.toInstant(), dateTime.getZone() );
						    }

						    @Override
						    public Clock getClock() {
						        return clock;
						    }

						}

					配置：

						xml:

							<clock-provider>org.hibernate.validator.referenceguide.chapter09.FixedClockProvider</clock-provider>

						api：
					
							ValidatorFactory validatorFactory = Validation.byDefaultProvider()
							        .configure()
							        .clockProvider( new FixedClockProvider( ZonedDateTime.of( 2016, 6, 15, 0, 0, 0, 0, ZoneId.of( "Europe/Paris" ) ) ) )
							        .buildValidatorFactory();
							Validator validator = validatorFactory.getValidator();	

				* Using temporal validation tolerance

					配置：

						xml:

							<property name="hibernate.validator.temporal_validation_tolerance">	
								java.time.Duration
							</property>	

						api:

							ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
							        .configure()
							        .temporalValidationTolerance( Duration.ofMillis( 10 ) )
							        .buildValidatorFactory();
							Validator validator = validatorFactory.getValidator();
				
			9.2.6. Registering ValueExtractors		
			
				* Registering additional value extractors		

					ValidatorFactory validatorFactory = Validation.byDefaultProvider()
					        .configure()
					        .addValueExtractor( new MultimapKeyValueExtractor() )
					        .addValueExtractor( new MultimapValueValueExtractor() )
					        .buildValidatorFactory();
					Validator validator = validatorFactory.getValidator();

			9.2.7. Adding mapping streams

				* Adding constraint mapping streams

					InputStream constraintMapping1 = null;
					InputStream constraintMapping2 = null;
					ValidatorFactory validatorFactory = Validation.byDefaultProvider()
					        .configure()
					        .addMapping( constraintMapping1 )
					        .addMapping( constraintMapping2 )
					        .buildValidatorFactory();
					Validator validator = validatorFactory.getValidator();

					tips: You should close any passed input stream after the validator factory has been created.

			9.2.8. Provider-specific settings		

				Via the configuration object returned by Validation#byProvider(), provider specific options can be configured.

				* Setting Hibernate Validator specific options

					ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
					        .configure()
					        .failFast( true )
					        .addMapping( (ConstraintMapping) null )
					        .buildValidatorFactory();
					Validator validator = validatorFactory.getValidator();

				* Enabling a Hibernate Validator specific option via addProperty()
				
					ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
					        .configure()
					        .addProperty( "hibernate.validator.fail_fast", "true" )
					        .buildValidatorFactory();
					Validator validator = validatorFactory.getValidator();	

			9.2.9. Configuring the ScriptEvaluatorFactory

				9.2.9.1. XML configuration

					<validation-config
					        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
					        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration
					            http://xmlns.jcp.org/xml/ns/validation/configuration/validation-configuration-2.0.xsd"
					        version="2.0">

					    <property name="hibernate.validator.script_evaluator_factory">
					        org.hibernate.validator.referenceguide.chapter09.CustomScriptEvaluatorFactory
					    </property>

					</validation-config>

					tips： In this case, the specified ScriptEvaluatorFactory must have a no-arg constructor.

				9.2.9.2. Programmatic configuration	

					* Defining the ScriptEvaluatorFactory programmatically

						ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
						        .configure()
						        .scriptEvaluatorFactory( new CustomScriptEvaluatorFactory() )
						        .buildValidatorFactory();
						Validator validator = validatorFactory.getValidator();

				9.2.9.3. Custom ScriptEvaluatorFactory implementation examples

					定义1：

						public class MultiClassLoaderScriptEvaluatorFactory extends AbstractCachingScriptEvaluatorFactory {

						    private final ClassLoader[] classLoaders;

						    public MultiClassLoaderScriptEvaluatorFactory(ClassLoader... classLoaders) {
						        if ( classLoaders.length == 0 ) {
						            throw new IllegalArgumentException( "No class loaders were passed" );
						        }
						        this.classLoaders = classLoaders;
						    }

						    @Override
						    protected ScriptEvaluator createNewScriptEvaluator(String languageName) {
						        for ( ClassLoader classLoader : classLoaders ) {
						            ScriptEngine engine = new ScriptEngineManager( classLoader ).getEngineByName( languageName );
						            if ( engine != null ) {
						                return new ScriptEngineScriptEvaluator( engine );
						            }
						        }
						        throw new ScriptEvaluationException( "No JSR 223 script engine found for language " + languageName );
						    }
						}

					配置：
						
						Validator validator = Validation.byProvider( HibernateValidator.class )
						        .configure()
						        .scriptEvaluatorFactory(
						                new MultiClassLoaderScriptEvaluatorFactory( GroovyScriptEngineFactory.class.getClassLoader() )
						        )
						        .buildValidatorFactory()
						        .getValidator();	

					定义2：
					
						public class OsgiScriptEvaluatorFactory extends AbstractCachingScriptEvaluatorFactory {

						    private final List<ScriptEngineManager> scriptEngineManagers;

						    public OsgiScriptEvaluatorFactory(BundleContext context) {
						        this.scriptEngineManagers = Collections.unmodifiableList( findManagers( context ) );
						    }

						    @Override
						    protected ScriptEvaluator createNewScriptEvaluator(String languageName) throws ScriptEvaluatorNotFoundException {
						        return scriptEngineManagers.stream()
						                .map( manager -> manager.getEngineByName( languageName ) )
						                .filter( Objects::nonNull )
						                .map( engine -> new ScriptEngineScriptEvaluator( engine ) )
						                .findFirst()
						                .orElseThrow( () -> new ValidationException( String.format( "Unable to find script evaluator for '%s'.", languageName ) ) );
						    }

						    private List<ScriptEngineManager> findManagers(BundleContext context) {
						        return findFactoryCandidates( context ).stream()
						                .map( className -> {
						                    try {
						                        return new ScriptEngineManager( Class.forName( className ).getClassLoader() );
						                    }
						                    catch (ClassNotFoundException e) {
						                        throw new ValidationException( "Unable to instantiate '" + className + "' based engine factory manager.", e );
						                    }
						                } ).collect( Collectors.toList() );
						    }

						    /**
						     * Iterates through all bundles to get the available {@link ScriptEngineFactory} classes
						     *
						     * @return the names of the available ScriptEngineFactory classes
						     *
						     * @throws IOException
						     */
						    private List<String> findFactoryCandidates(BundleContext context) {
						        return Arrays.stream( context.getBundles() )
						                .filter( Objects::nonNull )
						                .filter( bundle -> !"system.bundle".equals( bundle.getSymbolicName() ) )
						                .flatMap( this::toStreamOfResourcesURL )
						                .filter( Objects::nonNull )
						                .flatMap( url -> toListOfFactoryCandidates( url ).stream() )
						                .collect( Collectors.toList() );
						    }

						    private Stream<URL> toStreamOfResourcesURL(Bundle bundle) {
						        Enumeration<URL> entries = bundle.findEntries(
						                "META-INF/services",
						                "javax.script.ScriptEngineFactory",
						                false
						        );
						        return entries != null ? Collections.list( entries ).stream() : Stream.empty();
						    }

						    private List<String> toListOfFactoryCandidates(URL url) {
						        try ( BufferedReader reader = new BufferedReader( new InputStreamReader( url.openStream(), "UTF-8" ) ) ) {
						            return reader.lines()
						                    .map( String::trim )
						                    .filter( line -> !line.isEmpty() )
						                    .filter( line -> !line.startsWith( "#" ) )
						                    .collect( Collectors.toList() );
						        }
						        catch (IOException e) {
						            throw new ValidationException( "Unable to read the ScriptEngineFactory resource file", e );
						        }
						    }
						}	  

					配置：
					
						Validator validator = Validation.byProvider( HibernateValidator.class )
						        .configure()
						        .scriptEvaluatorFactory(
						                new OsgiScriptEvaluatorFactory( FrameworkUtil.getBundle( this.getClass() ).getBundleContext() )
						        )
						        .buildValidatorFactory()
						        .getValidator();

			        定义3：

			        	public class SpringELScriptEvaluatorFactory extends AbstractCachingScriptEvaluatorFactory {

						    @Override
						    public ScriptEvaluator createNewScriptEvaluator(String languageName) {
						        if ( !"spring".equalsIgnoreCase( languageName ) ) {
						            throw new IllegalStateException( "Only Spring EL is supported" );
						        }

						        return new SpringELScriptEvaluator();
						    }

						    private static class SpringELScriptEvaluator implements ScriptEvaluator {

						        private final ExpressionParser expressionParser = new SpelExpressionParser();

						        @Override
						        public Object evaluate(String script, Map<String, Object> bindings) throws ScriptEvaluationException {
						            try {
						                Expression expression = expressionParser.parseExpression( script );
						                EvaluationContext context = new StandardEvaluationContext( bindings.values().iterator().next() );
						                for ( Entry<String, Object> binding : bindings.entrySet() ) {
						                    context.setVariable( binding.getKey(), binding.getValue() );
						                }
						                return expression.getValue( context );
						            }
						            catch (ParseException | EvaluationException e) {
						                throw new ScriptEvaluationException( "Unable to evaluate SpEL script", e );
						            }
						        }
						    }
						}

					用例：

						@ScriptAssert(script = "value > 0", lang = "spring")
						public class Foo {

						    private final int value;

						    private Foo(int value) {
						        this.value = value;
						    }

						    public int getValue() {
						        return value;
						    }
						}	

		9.3. Configuring a Validator

			When working with a configured validator factory it can occasionally be required to apply a different configuration to a single Validator instance. 

			* Configuring a Validator instance via usingContext()

				ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();

				Validator validator = validatorFactory.usingContext()
				        .messageInterpolator( new MyMessageInterpolator() )
				        .traversableResolver( new MyTraversableResolver() )
				        .getValidator();

	10. Using constraint metadata	

		10.1. BeanDescriptor

			The entry point into the metadata API is the method Validator#getConstraintsForClass(), which returns an instance of the BeanDescriptor interface. Using this descriptor, you can obtain metadata for constraints declared directly on the bean itself (class- or property-level), but also retrieve metadata descriptors representing single properties, methods and constructors.

			* Using BeanDescriptor

				@Test
				public void testBeanDescriptor() {
					//tag::testBeanDescriptor[]
					BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );

					assertTrue( carDescriptor.isBeanConstrained() );

					//one class-level constraint
					assertEquals( 1, carDescriptor.getConstraintDescriptors().size() );

					//manufacturer, licensePlate, driver
					assertEquals( 3, carDescriptor.getConstrainedProperties().size() );

					//property has constraint
					assertNotNull( carDescriptor.getConstraintsForProperty( "licensePlate" ) );

					//property is marked with @Valid
					assertNotNull( carDescriptor.getConstraintsForProperty( "driver" ) );

					//constraints from getter method in interface and implementation class are returned
					assertEquals(
							2,
							carDescriptor.getConstraintsForProperty( "manufacturer" )
									.getConstraintDescriptors()
									.size()
					);

					//property is not constrained
					assertNull( carDescriptor.getConstraintsForProperty( "modelName" ) );

					//driveAway(int), load(List<Person>, List<PieceOfLuggage>)
					assertEquals( 2, carDescriptor.getConstrainedMethods( MethodType.NON_GETTER ).size() );

					//driveAway(int), getManufacturer(), getDriver(), load(List<Person>, List<PieceOfLuggage>)
					assertEquals(
							4,
							carDescriptor.getConstrainedMethods( MethodType.NON_GETTER, MethodType.GETTER )
									.size()
					);

					//driveAway(int)
					assertNotNull( carDescriptor.getConstraintsForMethod( "driveAway", int.class ) );

					//getManufacturer()
					assertNotNull( carDescriptor.getConstraintsForMethod( "getManufacturer" ) );

					//setManufacturer() is not constrained
					assertNull( carDescriptor.getConstraintsForMethod( "setManufacturer", String.class ) );

					//Car(String, String, Person, String)
					assertEquals( 1, carDescriptor.getConstrainedConstructors().size() );

					//Car(String, String, Person, String)
					assertNotNull(
							carDescriptor.getConstraintsForConstructor(
									String.class,
									String.class,
									Person.class,
									String.class
							)
					);
					//end::testBeanDescriptor[]
				}

		10.2. PropertyDescriptor		

			* Using PropertyDescriptor

				@Test
				public void testPropertyDescriptor() {
					BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );

					//tag::testPropertyDescriptor[]
					PropertyDescriptor licensePlateDescriptor = carDescriptor.getConstraintsForProperty(
							"licensePlate"
					);

					//"licensePlate" has two constraints, is not marked with @Valid and defines no group conversions
					assertEquals( "licensePlate", licensePlateDescriptor.getPropertyName() );
					assertEquals( 2, licensePlateDescriptor.getConstraintDescriptors().size() );
					assertTrue( licensePlateDescriptor.hasConstraints() );
					assertFalse( licensePlateDescriptor.isCascaded() );
					assertTrue( licensePlateDescriptor.getGroupConversions().isEmpty() );

					PropertyDescriptor driverDescriptor = carDescriptor.getConstraintsForProperty( "driver" );

					//"driver" has no constraints, is marked with @Valid and defines one group conversion
					assertEquals( "driver", driverDescriptor.getPropertyName() );
					assertTrue( driverDescriptor.getConstraintDescriptors().isEmpty() );
					assertFalse( driverDescriptor.hasConstraints() );
					assertTrue( driverDescriptor.isCascaded() );
					assertEquals( 1, driverDescriptor.getGroupConversions().size() );
					//end::testPropertyDescriptor[]
				}

		10.3. MethodDescriptor and ConstructorDescriptor	

			* Using MethodDescriptor and ConstructorDescriptor

				@Test
				public void testMethodAndConstructorDescriptor() {
					BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );

					//tag::testMethodAndConstructorDescriptor[]
					//driveAway(int) has a constrained parameter and an unconstrained return value
					MethodDescriptor driveAwayDescriptor = carDescriptor.getConstraintsForMethod(
							"driveAway",
							int.class
					);
					assertEquals( "driveAway", driveAwayDescriptor.getName() );
					assertTrue( driveAwayDescriptor.hasConstrainedParameters() );
					assertFalse( driveAwayDescriptor.hasConstrainedReturnValue() );

					//always returns an empty set; constraints are retrievable by navigating to
					//one of the sub-descriptors, e.g. for the return value
					assertTrue( driveAwayDescriptor.getConstraintDescriptors().isEmpty() );

					ParameterDescriptor speedDescriptor = driveAwayDescriptor.getParameterDescriptors()
							.get( 0 );

					//The "speed" parameter is located at index 0, has one constraint and is not cascaded
					//nor does it define group conversions
					assertEquals( "speed", speedDescriptor.getName() );
					assertEquals( 0, speedDescriptor.getIndex() );
					assertEquals( 1, speedDescriptor.getConstraintDescriptors().size() );
					assertFalse( speedDescriptor.isCascaded() );
					assert speedDescriptor.getGroupConversions().isEmpty();

					//getDriver() has no constrained parameters but its return value is marked for cascaded
					//validation and declares one group conversion
					MethodDescriptor getDriverDescriptor = carDescriptor.getConstraintsForMethod(
							"getDriver"
					);
					assertFalse( getDriverDescriptor.hasConstrainedParameters() );
					assertTrue( getDriverDescriptor.hasConstrainedReturnValue() );

					ReturnValueDescriptor returnValueDescriptor = getDriverDescriptor.getReturnValueDescriptor();
					assertTrue( returnValueDescriptor.getConstraintDescriptors().isEmpty() );
					assertTrue( returnValueDescriptor.isCascaded() );
					assertEquals( 1, returnValueDescriptor.getGroupConversions().size() );

					//load(List<Person>, List<PieceOfLuggage>) has one cross-parameter constraint
					MethodDescriptor loadDescriptor = carDescriptor.getConstraintsForMethod(
							"load",
							List.class,
							List.class
					);
					assertTrue( loadDescriptor.hasConstrainedParameters() );
					assertFalse( loadDescriptor.hasConstrainedReturnValue() );
					assertEquals(
							1,
							loadDescriptor.getCrossParameterDescriptor().getConstraintDescriptors().size()
					);

					//Car(String, String, Person, String) has one constrained parameter
					ConstructorDescriptor constructorDescriptor = carDescriptor.getConstraintsForConstructor(
							String.class,
							String.class,
							Person.class,
							String.class
					);

					assertEquals( "Car", constructorDescriptor.getName() );
					assertFalse( constructorDescriptor.hasConstrainedReturnValue() );
					assertTrue( constructorDescriptor.hasConstrainedParameters() );
					assertEquals(
							1,
							constructorDescriptor.getParameterDescriptors()
									.get( 0 )
									.getConstraintDescriptors()
									.size()
					);
					//end::testMethodAndConstructorDescriptor[]
				}	

		10.4. ElementDescriptor

			The ElementDescriptor interface is the common base class for the individual descriptor types such as BeanDescriptor, PropertyDescriptor etc. Besides getConstraintDescriptors() it provides some more methods common to all descriptors.

			* Using ElementDescriptor methods：

				@Test
				public void testElementDescriptor() {
					BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );

					//tag::testElementDescriptor[]
					PropertyDescriptor manufacturerDescriptor = carDescriptor.getConstraintsForProperty(
							"manufacturer"
					);

					assertTrue( manufacturerDescriptor.hasConstraints() );
					assertEquals( String.class, manufacturerDescriptor.getElementClass() );

					CrossParameterDescriptor loadCrossParameterDescriptor = carDescriptor.getConstraintsForMethod(
							"load",
							List.class,
							List.class
					).getCrossParameterDescriptor();

					assertTrue( loadCrossParameterDescriptor.hasConstraints() );
					assertEquals( Object[].class, loadCrossParameterDescriptor.getElementClass() );
					//end::testElementDescriptor[]
				}

			* Usage of ConstraintFinder
			
				@Test
				public void testConstraintFinderApi() {
					BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );

					//tag::testConstraintFinderApi[]
					PropertyDescriptor manufacturerDescriptor = carDescriptor.getConstraintsForProperty(
							"manufacturer"
					);

					//"manufacturer" constraints are declared on the getter, not the field
					assertTrue(
							manufacturerDescriptor.findConstraints()
									.declaredOn( ElementType.FIELD )
									.getConstraintDescriptors()
									.isEmpty()
					);

					//@NotNull on Vehicle#getManufacturer() is part of another group
					assertEquals(
							1,
							manufacturerDescriptor.findConstraints()
									.unorderedAndMatchingGroups( Default.class )
									.getConstraintDescriptors()
									.size()
					);

					//@Size on Car#getManufacturer()
					assertEquals(
							1,
							manufacturerDescriptor.findConstraints()
									.lookingAt( Scope.LOCAL_ELEMENT )
									.getConstraintDescriptors()
									.size()
					);

					//@Size on Car#getManufacturer() and @NotNull on Vehicle#getManufacturer()
					assertEquals(
							2,
							manufacturerDescriptor.findConstraints()
									.lookingAt( Scope.HIERARCHY )
									.getConstraintDescriptors()
									.size()
					);

					//Combining several filter options
					assertEquals(
							1,
							manufacturerDescriptor.findConstraints()
									.declaredOn( ElementType.METHOD )
									.lookingAt( Scope.HIERARCHY )
									.unorderedAndMatchingGroups( Vehicle.Basic.class )
									.getConstraintDescriptors()
									.size()
					);
					//end::testConstraintFinderApi[]
				}

		10.5. ContainerDescriptor and ContainerElementTypeDescriptor

			* Using ContainerElementTypeDescriptor

				PropertyDescriptor booksDescriptor = libraryDescriptor.getConstraintsForProperty(
				        "books"
				);

				Set<ContainerElementTypeDescriptor> booksContainerElementTypeDescriptors =
				        booksDescriptor.getConstrainedContainerElementTypes();
				ContainerElementTypeDescriptor booksContainerElementTypeDescriptor =
				        booksContainerElementTypeDescriptors.iterator().next();

				assertTrue( booksContainerElementTypeDescriptor.hasConstraints() );
				assertTrue( booksContainerElementTypeDescriptor.isCascaded() );
				assertEquals(
				        0,
				        booksContainerElementTypeDescriptor.getTypeArgumentIndex().intValue()
				);
				assertEquals(
				        List.class,
				        booksContainerElementTypeDescriptor.getContainerClass()
				);

				Set<ConstraintDescriptor<?>> constraintDescriptors =
				        booksContainerElementTypeDescriptor.getConstraintDescriptors();
				ConstraintDescriptor<?> constraintDescriptor =
				        constraintDescriptors.iterator().next();

				assertEquals(
				        NotNull.class,
				        constraintDescriptor.getAnnotation().annotationType()
				);

			10.6. GroupConversionDescriptor
			
				* Using GroupConversionDescriptor

					@Test
					public void testGroupConversionDescriptor() {
						BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );
						//tag::testGroupConversionDescriptor[]
						PropertyDescriptor driverDescriptor = carDescriptor.getConstraintsForProperty( "driver" );

						Set<GroupConversionDescriptor> groupConversions = driverDescriptor.getGroupConversions();
						assertEquals( 1, groupConversions.size() );

						GroupConversionDescriptor groupConversionDescriptor = groupConversions.iterator()
								.next();
						assertEquals( Default.class, groupConversionDescriptor.getFrom() );
						assertEquals( Person.Basic.class, groupConversionDescriptor.getTo() );
						//end::testGroupConversionDescriptor[]
					}

			10.7. ConstraintDescriptor

				* Using ConstraintDescriptor

					@Test
					public void testConstraintDescriptor() {
						BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );

						//tag::testConstraintDescriptor[]
						//descriptor for the @LuggageCountMatchesPassengerCount constraint on the
						//load(List<Person>, List<PieceOfLuggage>) method
						ConstraintDescriptor<?> constraintDescriptor = carDescriptor.getConstraintsForMethod(
								"load",
								List.class,
								List.class
						).getCrossParameterDescriptor().getConstraintDescriptors().iterator().next();

						//constraint type
						assertEquals(
								LuggageCountMatchesPassengerCount.class,
								constraintDescriptor.getAnnotation().annotationType()
						);

						//standard constraint attributes
						assertEquals( SeverityInfo.class, constraintDescriptor.getPayload().iterator().next() );
						assertEquals(
								ConstraintTarget.PARAMETERS,
								constraintDescriptor.getValidationAppliesTo()
						);
						assertEquals( Default.class, constraintDescriptor.getGroups().iterator().next() );
						assertEquals(
								"There must not be more than {piecesOfLuggagePerPassenger} pieces of luggage per " +
								"passenger.",
								constraintDescriptor.getMessageTemplate()
						);

						//custom constraint attribute
						assertEquals(
								2,
								constraintDescriptor.getAttributes().get( "piecesOfLuggagePerPassenger" )
						);

						//no composing constraints
						assertTrue( constraintDescriptor.getComposingConstraints().isEmpty() );

						//validator class
						assertEquals(
								Arrays.<Class<?>>asList( LuggageCountMatchesPassengerCount.Validator.class ),
								constraintDescriptor.getConstraintValidatorClasses()
						);
						//end::testConstraintDescriptor[]
					}

	11. Integrating with other frameworks

		11.1. ORM integration

			11.1.1. Database schema-level validation

			11.1.2. Hibernate ORM event-based validation

				In case you need to manually set the event listeners for Hibernate ORM, use the following configuration in hibernate.cfg.xml:

					* Manual configuration of BeanValidationEvenListener

						<hibernate-configuration>
						    <session-factory>
						        ...
						        <property name="javax.persistence.validation.group.pre-persist">
						            javax.validation.groups.Default
						        </property>
						        <property name="javax.persistence.validation.group.pre-update">
						            javax.validation.groups.Default
						        </property>
						        <property name="javax.persistence.validation.group.pre-remove"></property>
						        ...
						        <event type="pre-update">
						            <listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/>
						        </event>
						        <event type="pre-insert">
						            <listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/>
						        </event>
						        <event type="pre-delete">
						            <listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/>
						        </event>
						    </session-factory>
						</hibernate-configuration>

			11.1.3. JPA

				If you are using JPA 2 and Hibernate Validator is in the classpath, the JPA2 specification requires that Bean Validation gets enabled. The properties javax.persistence.validation.group.pre-persist, javax.persistence.validation.group.pre-update and javax.persistence.validation.group.pre-remove as described in Section 11.1.2, “Hibernate ORM event-based validation” can in this case be configured in persistence.xml. persistence.xml also defines a node validation-mode which can be set to AUTO, CALLBACK or NONE. The default is AUTO.

		11.2. JSF & Seam

			* Usage of Bean Validation within JSF2

				<h:form>

				  <f:validateBean validationGroups="javax.validation.groups.Default">

				    <h:inputText value=#{model.property}/>
				    <h:selectOneRadio value=#{model.radioProperty}> ... </h:selectOneRadio>
				    <!-- other input components here -->

				  </f:validateBean>

				</h:form>

		11.3. CDI

			11.3.1. Dependency injection

				* Retrieving validator factory and validator via @Inject

					@ApplicationScoped
					public class RentalStation {

						@Inject
						private ValidatorFactory validatorFactory;

						@Inject
						private Validator validator;

						//...
					}

				* Using the @HibernateValidator qualifier annotation
				
					@ApplicationScoped
					public class RentalStation {

						@Inject
						@HibernateValidator
						private ValidatorFactory validatorFactory;

						@Inject
						@HibernateValidator
						private Validator validator;

						//...
					}	

				* Constraint validator with injected bean
				
					public class ValidLicensePlateValidator
							implements ConstraintValidator<ValidLicensePlate, String> {

						@Inject
						private VehicleRegistry vehicleRegistry;

						@PostConstruct
						public void postConstruct() {
							//do initialization logic...
						}

						@PreDestroy
						public void preDestroy() {
							//do destruction logic...
						}

						@Override
						public void initialize(ValidLicensePlate constraintAnnotation) {
						}

						@Override
						public boolean isValid(String licensePlate, ConstraintValidatorContext constraintContext) {
							return vehicleRegistry.isValidLicensePlate( licensePlate );
						}
					}	

			11.3.2. Method validation

				* CDI managed beans with method-level constraints

					@ApplicationScoped
					public class RentalStation {

						@Valid
						public RentalStation() {
							//...
						}

						@NotNull
						@Valid
						public Car rentCar(
								@NotNull Customer customer,
								@NotNull @Future Date startDate,
								@Min(1) int durationInDays) {
							//...
							return null;
						}

						@NotNull
						List<Car> getAvailableCars() {
							//...
							return null;
						}
					}
			
					@RequestScoped
					public class RentCarRequest {

						@Inject
						private RentalStation rentalStation;

						public void rentCar(String customerId, Date startDate, int duration) {
							//causes ConstraintViolationException
							rentalStation.rentCar( null, null, -1 );
						}
					}

				11.3.2.1. Validated executable types		

					* Using @ValidateOnExecution

						@ApplicationScoped
						@ValidateOnExecution(type = ExecutableType.ALL)
						public class RentalStation {

							@Valid
							public RentalStation() {
								//...
							}

							@NotNull
							@Valid
							@ValidateOnExecution(type = ExecutableType.NONE)
							public Car rentCar(
									@NotNull Customer customer,
									@NotNull @Future Date startDate,
									@Min(1) int durationInDays) {
								//...
								return null;
							}

							@NotNull
							public List<Car> getAvailableCars() {
								//...
								return null;
							}
						}

					* Using ExecutableType.IMPLICIT

						@ValidateOnExecution(type = ExecutableType.ALL)
						public interface RentalStation {

							@NotNull
							@Valid
							Car rentCar(
									@NotNull Customer customer,
									@NotNull @Future Date startDate,
									@Min(1) int durationInDays);

							@NotNull
							List<Car> getAvailableCars();
						}

						@ApplicationScoped
						@ValidateOnExecution(type = ExecutableType.IMPLICIT)
						public class ExpressRentalStation implements RentalStation {

							@Override
							public Car rentCar(Customer customer, Date startDate, @Min(1) int durationInDays) {
								//...
								return null;
							}

							@Override
							public List<Car> getAvailableCars() {
								//...
								return null;
							}
						}

		11.4. Java EE					

			* Retrieving Validator and ValidatorFactory via @Resource injection

				public class RentalStationBean {

				    @Resource
				    private ValidatorFactory validatorFactory;

				    @Resource
				    private Validator validator;

				    //...
				}

		11.5. JavaFX

	12. Hibernate Validator Specifics			

		12.1. Public API

		12.2. Fail fast mode

			Using the fail fast mode, Hibernate Validator allows to return from the current validation as soon as the first constraint violation occurs. This can be useful for the validation of large object graphs where you are only interested in a quick check whether there is any constraint violation at all.

			有如下两种配置方式：

				方式1：

					Validator validator = Validation.byProvider( HibernateValidator.class )
					        .configure()
					        .failFast( true )
					        .buildValidatorFactory()
					        .getValidator();

				方式2：

					Validator validator = Validation.byProvider( HibernateValidator.class )
					        .configure()
					        .addProperty( "hibernate.validator.fail_fast", "true" )
					        .buildValidatorFactory()
					        .getValidator();

		12.3. Relaxation of requirements for method validation in class hierarchies

			*  Configuring method validation behaviour in class hierarchies via properties

				<?xml version="1.0" encoding="UTF-8"?>
				<validation-config
				        xmlns="http://xmlns.jcp.org/xml/ns/validation/configuration"
				        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
				        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/validation/configuration validation-configuration-2.0.xsd"
				        version="2.0">
				    <default-provider>org.hibernate.validator.HibernateValidator</default-provider>

				    <property name="hibernate.validator.allow_parameter_constraint_override">true</property>
				    <property name="hibernate.validator.allow_multiple_cascaded_validation_on_result">true</property>
				    <property name="hibernate.validator.allow_parallel_method_parameter_constraint">true</property>
				</validation-config>

			* Configuring method validation behaviour in class hierarchies
			
				HibernateValidatorConfiguration configuration = Validation.byProvider( HibernateValidator.class ).configure();

				configuration.allowMultipleCascadedValidationOnReturnValues( true )
				        .allowOverridingMethodAlterParameterConstraint( true )
				        .allowParallelMethodsDefineParameterConstraints( true );

		12.4. Programmatic constraint definition and declaration	

			As per the Bean Validation specification, you can define and declare constraints using Java annotations and XML based constraint mappings.
			In addition, Hibernate Validator provides a fluent API which allows for the programmatic configuration of constraints. Use cases include the dynamic addition of constraints at runtime depending on some application state or tests where you need entities with different constraints in different scenarios but don’t want to implement actual Java classes for each test case.

			* Programmatic constraint declaration

				HibernateValidatorConfiguration configuration = Validation
				        .byProvider( HibernateValidator.class )
				        .configure();

				ConstraintMapping constraintMapping = configuration.createConstraintMapping();

				constraintMapping
				    .type( Car.class )
				        .property( "manufacturer", FIELD )
				            .constraint( new NotNullDef() )
				        .property( "licensePlate", FIELD )
				            .ignoreAnnotations( true )
				            .constraint( new NotNullDef() )
				            .constraint( new SizeDef().min( 2 ).max( 14 ) )
				    .type( RentalCar.class )
				        .property( "rentalStation", METHOD )
				            .constraint( new NotNullDef() );

				Validator validator = configuration.addMapping( constraintMapping )
				        .buildValidatorFactory()
				        .getValidator();

		      tips：

		      	1. Each element (type, property, method etc.) may only be configured once within all the constraint mappings used to set up one validator factory. Otherwise a ValidationException is raised.

		      	2. It is not supported to add constraints to non-overridden supertype properties and methods by configuring a subtype. Instead you need to configure the supertype in this case.  

      		* Programmatic declaration of a custom constraint

      			ConstraintMapping constraintMapping = configuration.createConstraintMapping();

				constraintMapping
				    .type( Car.class )
				        .property( "licensePlate", FIELD )
				            .constraint( new GenericConstraintDef<>( CheckCase.class )
				                .param( "value", CaseMode.UPPER )
				            );

            * Programmatic declaration of a nested container element constraint

            	ConstraintMapping constraintMapping = configuration.createConstraintMapping();

				constraintMapping
				    .type( Car.class )
				        .property( "manufacturer", FIELD )
				            .constraint( new NotNullDef() )
				        .property( "licensePlate", FIELD )
				            .ignoreAnnotations( true )
				            .constraint( new NotNullDef() )
				            .constraint( new SizeDef().min( 2 ).max( 14 ) )
				        .property( "partManufacturers", FIELD )
				            .containerElementType( 0 )
				                .constraint( new NotNullDef() )
				            .containerElementType( 1, 0 )
				                .constraint( new NotNullDef() )
				    .type( RentalCar.class )
				        .property( "rentalStation", METHOD )
				            .constraint( new NotNullDef() );

            * Marking a property for cascaded validation

            	ConstraintMapping constraintMapping = configuration.createConstraintMapping();

				constraintMapping
				    .type( Car.class )
				        .property( "driver", FIELD )
				            .constraint( new NotNullDef() )
				            .valid()
				            .convertGroup( Default.class ).to( PersonDefault.class )
				        .property( "partManufacturers", FIELD )
				            .containerElementType( 0 )
				                .valid()
				            .containerElementType( 1, 0 )
				                .valid()
				    .type( Person.class )
				        .property( "name", FIELD )

	        * Programmatic declaration of method and constructor constraints

	        	ConstraintMapping constraintMapping = configuration.createConstraintMapping();

				constraintMapping
				    .type( Car.class )
				        .constructor( String.class )
				            .parameter( 0 )
				                .constraint( new SizeDef().min( 3 ).max( 50 ) )
				            .returnValue()
				                .valid()
				        .method( "drive", int.class )
				            .parameter( 0 )
				                .constraint( new MaxDef().value( 75 ) )
				        .method( "load", List.class, List.class )
				            .crossParameter()
				                .constraint( new GenericConstraintDef<>(
				                        LuggageCountMatchesPassengerCount.class ).param(
				                            "piecesOfLuggagePerPassenger", 2
				                        )
				                )
				        .method( "getDriver" )
				            .returnValue()
				                .constraint( new NotNullDef() )
				                .valid();

            * Configuration of default group sequence and default group sequence provider

            	ConstraintMapping constraintMapping = configuration.createConstraintMapping();

				constraintMapping
				    .type( Car.class )
				        .defaultGroupSequence( Car.class, CarChecks.class )
				    .type( RentalCar.class )
				        .defaultGroupSequenceProviderClass( RentalCarGroupSequenceProvider.class );

		12.5. Applying programmatic constraint declarations to the default validator factory

			* Custom ConstraintMappingContributor implementation

				定义：

					public class MyConstraintMappingContributor implements ConstraintMappingContributor {

					    @Override
					    public void createConstraintMappings(ConstraintMappingBuilder builder) {
					        builder.addConstraintMapping()
					            .type( Marathon.class )
					                .property( "name", METHOD )
					                    .constraint( new NotNullDef() )
					                .property( "numberOfHelpers", FIELD )
					                    .constraint( new MinDef().value( 1 ) );

					        builder.addConstraintMapping()
					            .type( Runner.class )
					                .property( "paidEntryFee", FIELD )
					                    .constraint( new AssertTrueDef() );
					    }
					}

				配置：（META-INF/validation.xml）

					<property name="hibernate.validator.constraint_mapping_contributors">
						org.hibernate.validator.referenceguide.chapter12.constraintapi.MyConstraintMappingContributor,...,...(多个用逗号隔开)
					</property>

		12.6. Advanced constraint composition features

			12.6.1. Validation target specification for purely composed constraints

				@Min(value = 0)
				@NotNull
				@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
				@Retention(RUNTIME)
				@Documented
				@Constraint(validatedBy = {})
				@SupportedValidationTarget(ValidationTarget.ANNOTATED_ELEMENT)
				@ReportAsSingleViolation
				public @interface ValidInvoiceAmount {

					String message() default "{org.hibernate.validator.referenceguide.chapter11.purelycomposed."
							+ "ValidInvoiceAmount.message}";

					Class<?>[] groups() default {};

					Class<? extends Payload>[] payload() default {};

					@OverridesAttribute(constraint = Min.class, name = "value")
					long value();
				}
				

				解释：

					1. Hibernate Validator allows to resolve such ambiguities by specifying the @SupportedValidationTarget annotation on the declaration of the composed constraint type	

					2. The @ValidInvoiceAmount does not declare any validator, but it is solely composed by the @Min and @NotNull constraints. 

					3. The @SupportedValidationTarget ensures that the constraint is applied to the method return value when given on a method declaration.

			12.6.2. Boolean composition of constraints

				Hibernate Validator offers an extension to this and allows you to compose constraints via a logical OR or NOT. To do so, you have to use the ConstraintComposition annotation and the enum CompositionType with its values AND, OR and ALL_FALSE.

				* OR composition of constraints

					@ConstraintComposition(OR)
					@Pattern(regexp = "[a-z]")
					@Size(min = 2, max = 3)
					@ReportAsSingleViolation
					@Target({ METHOD, FIELD })
					@Retention(RUNTIME)
					@Constraint(validatedBy = { })
					public @interface PatternOrSize {
						String message() default "{org.hibernate.validator.referenceguide.chapter11." +
								"booleancomposition.PatternOrSize.message}";

						Class<?>[] groups() default { };

						Class<? extends Payload>[] payload() default { };
					}

					tips:

						1. @PatternOrSize means only one of the composing constraints needs to be valid in order to pass the validation. Either the validated string is all lower-cased or it is between two and three characters long.

						2. Using ALL_FALSE as composition type implicitly enforces that only a single violation will get reported in case validation of the constraint composition fails.

		12.7. Extensions of the Path API
		
			* Getting the value from property nodes

				public class Person {

					@Size(min = 5)
					String name;

					Person(String name) {
						this.name = name;
					}
				}

				public class Apartment {

					@Valid
					Person resident;

					Apartment(Person resident) {
						this.resident = resident;
					}
				}

				public class Building {

					@Valid
					private Set<Apartment> apartments = new HashSet<Apartment>();

					public Set<Apartment> getApartments() {
						return apartments;
					}

					public void setApartments(Set<Apartment> apartments) {
						this.apartments = apartments;
					}
				}

				public class PropertyPathTest {

					@Test
					public void testPropertyNodeGetValueForSet() {
						Validator validator = Validation.byProvider( HibernateValidator.class )
								.configure()
								.failFast( true )
								.buildValidatorFactory()
								.getValidator();

				//tag::include[]
						Building building = new Building();

						// Assume the name of the person violates a @Size constraint
						Person bob = new Person( "Bob" );
						Apartment bobsApartment = new Apartment( bob );
						building.getApartments().add( bobsApartment );

						Set<ConstraintViolation<Building>> constraintViolations = validator.validate( building );

						Path path = constraintViolations.iterator().next().getPropertyPath();
						Iterator<Path.Node> nodeIterator = path.iterator();

						Path.Node node = nodeIterator.next();
						assertEquals( node.getName(), "apartments" );
						assertSame( node.as( PropertyNode.class ).getValue(), bobsApartment );

						node = nodeIterator.next();
						assertEquals( node.getName(), "resident" );
						assertSame( node.as( PropertyNode.class ).getValue(), bob );

						node = nodeIterator.next();
						assertEquals( node.getName(), "name" );
						assertEquals( node.as( PropertyNode.class ).getValue(), "Bob" );
				//end::include[]

						assertFalse( nodeIterator.hasNext() );
					}
				}			

		12.8. Dynamic payload as part of ConstraintViolation	

			* POJO类：

				@ValidPassengerCount
				public class Car {
					private final int seatCount;
					private final List<Person> passengers;

					public Car(int seatCount) {
						this.seatCount = seatCount;
						this.passengers = new ArrayList<>();
					}

					public int getSeatCount() {
						return seatCount;
					}

					public List<Person> getPassengers() {
						return passengers;
					}

					public void addPassenger(Person passenger) {
						passengers.add( passenger );
					}
				}

				public class Person {}

			* 校验注解类 + 校验器：
			
				@Target({ TYPE, ANNOTATION_TYPE })
				@Retention(RUNTIME)
				@Constraint(validatedBy = { ValidPassengerCountValidator.class })
				@Documented
				public @interface ValidPassengerCount {

					String message() default "The passenger count is exceeding the number of seats in the car";

					Class<?>[] groups() default {};

					Class<? extends Payload>[] payload() default {};
				}	

				public class ValidPassengerCountValidator implements ConstraintValidator<ValidPassengerCount, Car> {

					private static final Map<Integer, String> suggestedCars = newHashMap();

					static {
						suggestedCars.put( 2, "Chevrolet Corvette" );
						suggestedCars.put( 3, "Toyota Volta" );
						suggestedCars.put( 4, "Maserati GranCabrio" );
						suggestedCars.put( 5, " Mercedes-Benz E-Class" );
					}

					@Override
					public void initialize(ValidPassengerCount constraintAnnotation) {
					}

					@Override
					public boolean isValid(Car car, ConstraintValidatorContext context) {
						if ( car == null ) {
							return true;
						}

						int passengerCount = car.getPassengers().size();
						if ( car.getSeatCount() >= passengerCount ) {
							return true;
						}
						else {

							if ( suggestedCars.containsKey( passengerCount ) ) {
								HibernateConstraintValidatorContext hibernateContext = context.unwrap(
										HibernateConstraintValidatorContext.class
								);
								hibernateContext.withDynamicPayload( suggestedCars.get( passengerCount ) );
							}
							return false;
						}
					}
				}

			* 测试类：
				
				public class DynamicPayLoadTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();
						validator = validatorFactory.getValidator();
					}

					@Test
					public void testDynamicPayloadAddedToConstraintViolation() throws Exception {
						//tag::include[]
						Car car = new Car( 2 );
						car.addPassenger( new Person() );
						car.addPassenger( new Person() );
						car.addPassenger( new Person() );
						Set<ConstraintViolation<Car>> constraintViolations = validator.validate( car );

						assertEquals( 1, constraintViolations.size() );

						ConstraintViolation<Car> constraintViolation = constraintViolations.iterator().next();
						@SuppressWarnings("unchecked")
						HibernateConstraintViolation<Car> hibernateConstraintViolation = constraintViolation.unwrap(
								HibernateConstraintViolation.class
						);
						String suggestedCar = hibernateConstraintViolation.getDynamicPayload( String.class );
						assertEquals( "Toyota Volta", suggestedCar );
						//end::include[]
					}
				}

		12.9. ParameterMessageInterpolator

			具体使用参见4.2, "Custom message interpolation"

		12.10. ResourceBundleLocator

			具体使用参见4.2.1, “ResourceBundleLocator”

		12.11. Custom contexts

			12.11.1. HibernateConstraintValidatorContext

				HibernateConstraintValidatorContext is a subtype of ConstraintValidatorContext which allows you to:

					1. set arbitrary parameters for interpolation via the Expression Language message interpolation facility using HibernateConstraintValidatorContext#addExpressionVariable(String, Object) or HibernateConstraintValidatorContext#addMessageParameter(String, Object).

						示例：

							* Custom @Future validator injecting an expression variable

								public class MyFutureValidator implements ConstraintValidator<Future, Instant> {

									@Override
									public void initialize(Future constraintAnnotation) {
									}

									@Override
									public boolean isValid(Instant value, ConstraintValidatorContext context) {
										if ( value == null ) {
											return true;
										}

										HibernateConstraintValidatorContext hibernateContext = context.unwrap(
												HibernateConstraintValidatorContext.class
										);

										Instant now = Instant.now( context.getClockProvider().getClock() );

										if ( !value.isAfter( now ) ) {
											hibernateContext.disableDefaultConstraintViolation();
											hibernateContext
													.addExpressionVariable( "now", now )
													.buildConstraintViolationWithTemplate( "Must be after ${now}" )
													.addConstraintViolation();

											return false;
										}

										return true;
									}
								}

							* Custom @Future validator injecting a message parameter
							
								public class MyFutureValidatorMessageParameter implements ConstraintValidator<Future, Instant> {

									@Override
									public void initialize(Future constraintAnnotation) {
									}

									@Override
									public boolean isValid(Instant value, ConstraintValidatorContext context) {
										if ( value == null ) {
											return true;
										}

										HibernateConstraintValidatorContext hibernateContext = context.unwrap(
												HibernateConstraintValidatorContext.class
										);

										Instant now = Instant.now( context.getClockProvider().getClock() );

										if ( !value.isAfter( now ) ) {
											hibernateContext.disableDefaultConstraintViolation();
											hibernateContext
													.addMessageParameter( "now", now )
													.buildConstraintViolationWithTemplate( "Must be after {now}" )
													.addConstraintViolation();

											return false;
										}

										return true;
									}
								}	

						tips：

							Apart from the syntax, the main difference between message parameters and expression variables is that message parameters are simply interpolated whereas expression variables are interpreted using the expression language engine. In practice, it should not change anything.

					2. set an arbitrary dynamic payload - see Section 12.8, “Dynamic payload as part of ConstraintViolation”

			12.11.2. HibernateMessageInterpolatorContext

		12.12. Paranamer based ParameterNameProvider

			有以下两种使用途径：

				1. pass an instance when bootstrapping a validator

					public class MyParameterNameProvider implements ParameterNameProvider {

					    @Override
					    public List<String> getParameterNames(Constructor<?> constructor) {
					        //...
					        return null;
					    }

					    @Override
					    public List<String> getParameterNames(Method method) {
					        //...
					        return null;
					    }
					}

					ValidatorFactory validatorFactory = Validation.byDefaultProvider()
					        .configure()
					        .parameterNameProvider( new MyParameterNameProvider() )
					        .buildValidatorFactory();
					Validator validator = validatorFactory.getValidator();

				2. specify org.hibernate.validator.parameternameprovider.ParanamerParameterNameProvider as value for the <parameter-name-provider> element in the META-INF/validation.xml file.

					<parameter-name-provider>com.acme.ParameterNameProvider</parameter-name-provider>

			tips:
			
				When using this parameter name provider, you need to add the Paranamer library to your classpath. It is available in the Maven Central repository with the group id com.thoughtworks.paranamer and the artifact id paranamer.	

		12.13. Providing constraint definitions

			12.13.1. Constraint definitions via ServiceLoader

				* META-INF/services/javax.validation.ConstraintValidator

					# Assuming a custom constraint annotation @org.mycompany.CheckCase
					org.mycompany.CheckCaseValidator

			12.13.2. Adding constraint definitions programmatically

				* Adding constraint definitions through the programmatic API

					ConstraintMapping constraintMapping = configuration.createConstraintMapping();

					constraintMapping
					        .constraintDefinition( ValidPassengerCount.class )
					        .validatedBy( ValidPassengerCountValidator.class );

		        * Adding constraint definition with a Lambda expression

		        	onstraintMapping constraintMapping = configuration.createConstraintMapping();

					constraintMapping
					        .constraintDefinition( ValidPassengerCount.class )
					            .validateType( Bus.class )
					                .with( b -> b.getSeatCount() >= b.getPassengers().size() );

                * Using the programmatic constraint declaration API to register a regular expression based constraint definition for @URL

                	ConstraintMapping constraintMapping = configuration.createConstraintMapping();

					constraintMapping
					        .constraintDefinition( URL.class )
					        .includeExistingValidators( false )
					        .validatedBy( RegexpURLValidator.class );

		12.14. Customizing class-loading

			* Providing a class loader for loading external resources and classes

				public class ClassLoadingTest {

					@Test
					public void setupValidator() {
						ClassLoader classLoader = ClassLoadingTest.class.getClassLoader();

						//tag::setupValidator[]
						Validator validator = Validation.byProvider( HibernateValidator.class )
								.configure()
								.externalClassLoader( classLoader )
								.buildValidatorFactory()
								.getValidator();
						//end::setupValidator[]
					}
				}

			tips :
			
				Call ValidatorFactory#close() if a given validator factory instance is not needed any longer. Failure to do so may result in a class loader leak in cases where applications/bundles are re-deployed and a non-closed validator factory still is referenced by application code.	

	13. Annotation Processor

		13.1. Prerequisites

			The Hibernate Validator Annotation Processor is based on the "Pluggable Annotation Processing API" as defined by JSR 269 which is part of the Java Platform.

		13.2. Features	

			As of Hibernate Validator 6.0.17.Final the Hibernate Validator Annotation Processor checks that:

				* constraint annotations are allowed for the type of the annotated element
				* only non-static fields or methods are annotated with constraint annotations
				* only non-primitive fields or methods are annotated with @Valid
				* only such methods are annotated with constraint annotations which are valid JavaBeans getter methods (optionally, see below)
				* only such annotation types are annotated with constraint annotations which are constraint annotations themselves
				* definition of dynamic default group sequence with @GroupSequenceProvider is valid
				* annotation parameter values are meaningful and valid
				* method parameter constraints in inheritance hierarchies respect the inheritance rules
				* method return value constraints in inheritance hierarchies respect the inheritance rules

		13.3. Options

			The behavior of the Hibernate Validator Annotation Processor can be controlled using the following processor options:

				* diagnosticKind

					Controls how constraint problems are reported. Must be the string representation of one of the values from the enum javax.tools.Diagnostic.Kind, e.g. WARNING. A value of ERROR will cause compilation to halt whenever the AP detects a constraint problem. Defaults to ERROR.

				* methodConstraintsSupported
				
					Controls whether constraints are allowed at methods of any kind. Must be set to true when working with method level constraints as supported by Hibernate Validator. Can be set to false to allow constraints only at JavaBeans getter methods as defined by the Bean Validation API. Defaults to true.

				* verbose

					Controls whether detailed processing information shall be displayed or not, useful for debugging purposes. Must be either true or false. Defaults to false.

		13.4. Using the Annotation Processor		

			13.4.1. Command line builds

				13.4.1.1. Maven

					<project>
					    [...]
					    <build>
					        [...]
					        <plugins>
					            [...]
					            <plugin>
					                <groupId>org.apache.maven.plugins</groupId>
					                <artifactId>maven-compiler-plugin</artifactId>
					                <version>3.6.1</version>
					                <configuration>
					                    <source>1.8</source>
					                    <target>1.8</target>
					                    <annotationProcessorPaths>
					                        <path>
					                            <groupId>org.hibernate.validator</groupId>
					                            <artifactId>hibernate-validator-annotation-processor</artifactId>
					                            <version>6.0.17.Final</version>
					                        </path>
					                    </annotationProcessorPaths>
					                </configuration>
					            </plugin>
					            [...]
					        </plugins>
					        [...]
					    </build>
					    [...]
					</project>

			13.4.1.2. Apache Ant

				<javac srcdir="src/main"
				       destdir="build/classes"
				       classpath="/path/to/validation-api-2.0.1.Final.jar">
				       <compilerarg value="-processorpath" />
				       <compilerarg value="/path/to/hibernate-validator-annotation-processor-6.0.17.Final.jar"/>
				</javac>

			13.4.1.3. javac

				javac src/main/java/org/hibernate/validator/ap/demo/Car.java \
                      -cp /path/to/validation-api-2.0.1.Final.jar \
                      -processorpath /path/to/hibernate-validator-annotation-processor-6.0.17.Final.jar

      	13.4.2. IDE builds

      		13.4.2.1. Eclipse

      			For plain Eclipse projects follow these steps to set up the annotation processor:

					* Right-click your project, choose "Properties"
					* Go to "Java Compiler" and make sure, that "Compiler compliance level" is set to "1.8". Otherwise the processor won’t be activated
					* Go to "Java Compiler - Annotation Processing" and choose "Enable annotation processing"
					* Go to "Java Compiler - Annotation Processing - Factory Path" and add the JAR hibernate-validator-annotation-processor-6.0.17.Final.jar
					* Confirm the workspace rebuild

			13.4.2.2. IntelliJ IDEA

				The following steps must be followed to use the annotation processor within IntelliJ IDEA (version 9 and above):

					* Go to "File", then "Settings",
					* Expand the node "Compiler", then "Annotation Processors"
					* Choose "Enable annotation processing" and enter the following as "Processor path": /path/to/hibernate-validator-annotation-processor-6.0.17.Final.jar
					* Add the processor’s fully qualified name org.hibernate.validator.ap.ConstraintValidationProcessor to the "Annotation Processors" list
					* If applicable add you module to the "Processed Modules" list

			13.4.2.3. NetBeans

				The NetBeans IDE supports using annotation processors within the IDE build. To do so, do the following:
					* Right-click your project, choose "Properties"
					* Go to "Libraries", tab "Processor", and add the JAR hibernate-validator-annotation-processor-6.0.17.Final.jar
					* Go to "Build - Compiling", select "Enable Annotation Processing" and "Enable Annotation Processing in Editor". Add the annotation processor by specifying its fully qualified name org.hibernate.validator.ap.ConstraintValidationProcessor

		13.5. Known issues

	14. Further reading



