# Java数据校验：

	## 背景说明： 

		### 为什么要进行数据校验？什么场景下会用到数据校验？

			- web应用前后台交互（表现层）

					- 数据可能不会校验
					- 跳过前段数据校验，直接修改按钮样式等，然后直接提交表单到后台（比如有些表单数据是必输时，才会显示提交按钮等，但是会有人直接F12修改样式/前台JS校验方法）
					- 抓包工具拦截请求，修改数据信息，提交后台
					- 有一些业务逻辑相关的数据，在前台校验不方便

			- 接口开发中（服务层）

				- 对外提供接口

					接口字段，有多有少，几个/十几个/几十个，每个字段又有很多校验，比如非空/数值大小/字符串长度/日期时间格式等等，校验逻辑都在代码中实现：
						1. 通用性校验，业务逻辑关联性低
						2. 接口修改时，难以维护（比如，有些错误，只要出现就直接返回； 有些错误，是最后整合所有错误，一起提供给客户端）
						3. 校验程序执行也是不容忽视的（特别是接口调用次数很多的时候）

				- 调用外部接口	
						
					有两种选择：
						1. 不做任何校验，直接调用，信息校验交给接口提供方，返回错误
						2. 自己做校验，校验不通过，直接返回，校验通过再调用接口

			- 数据持久化（数据层）

				在数据持久化前，进行校验


		### 可用框架： 各个场景下，有哪些数据校验的方式？

			- 纯手工代码校验： 校验字段较少时

			- SpringMVC校验： 

				@RequestParam @NotNull...

			- Spring校验： 	

			- Hibernate-Validator： 

		### 为什么我们使用Hibernate-Validator框架？

			- 实现了Bean Validation JSR-380规范

Hibernate Validator 6.0.17.Final ——— JSR 380 Reference Implementation

前言：

	数据校验是贯穿所有应用层级的通用任务，从表现层到持久层，每层的校验逻辑基本相同，如果都单独实现，一是浪费时间，另外也容易发生错误。
	为了避免重复校验，开发一般会将校验逻辑直接绑定到实体类，但是实体类本身通常属于一个固定不变的元组件，添加校验代码后就会变得比较杂乱。


		Web页面  ————————  Controller展示层  ————————  Business业务层  ———————— DAO持久层  ————————  数据库
								\                                                  /
								 \________________________ java __________________/


	JSR 380 - Bean Validation - 定义了实体、方法校验的基础模型和API。 
	默认组件是使用注解，可以通过XML进行重写、扩展。 API也没有限制，配置/编码，Web层/持久层，server端/Swing端，均可以使用，

	Hibernate Validator就是JSR380的实现， 提供了对API、TCK的实现，在Apache Software License 2.0协议下开源。

1.开始

	前期准备：

		JDK1.8

		Maven

		有网（maven下载相关依赖使用）

	1.1 项目引入：

		pom.xml：

			<dependency>
				<groupId>org.hibernate.validator</groupId>
				<artifactId>hibernate-validator</artifactId>
				<version>6.0.17.Final</version>
			</dependency			

	1.2 使用约束：

		i.e：

			实体类：

				import javax.validation.constraints.Min;
				import javax.validation.constraints.NotNull;
				import javax.validation.constraints.Size;

				public class Car {

					@NotNull
					private String manufacturer;

					@NotNull
					@Size(min = 2, max = 14)
					private String licensePlate;

					@Min(2)
					private int seatCount;

					public Car(String manufacturer, String licencePlate, int seatCount) {
						this.manufacturer = manufacturer;
						this.licensePlate = licencePlate;
						this.seatCount = seatCount;
					}

					//getters and setters ...
				}

	1.3 校验约束：	

		i.e：	

			测试类：
			
				import java.util.Set;
				import javax.validation.ConstraintViolation;
				import javax.validation.Validation;
				import javax.validation.Validator;
				import javax.validation.ValidatorFactory;

				import org.junit.BeforeClass;
				import org.junit.Test;

				import static org.junit.Assert.assertEquals;

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void manufacturerIsNull() {
						Car car = new Car( null, "DD-AB-123", 4 );

						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );

						assertEquals( 1, constraintViolations.size() );
						assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );
					}

					@Test
					public void licensePlateTooShort() {
						Car car = new Car( "Morris", "D", 4 );

						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );

						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								"size must be between 2 and 14",
								constraintViolations.iterator().next().getMessage()
						);
					}

					@Test
					public void seatCountTooLow() {
						Car car = new Car( "Morris", "DD-AB-123", 1 );

						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );

						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								"must be greater than or equal to 2",
								constraintViolations.iterator().next().getMessage()
						);
					}

					@Test
					public void carIsValid() {
						Car car = new Car( "Morris", "DD-AB-123", 2 );

						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );

						assertEquals( 0, constraintViolations.size() );
					}
				}	

	1.4 推荐阅读

		Chapter14 Funter reading: Hibernate Validator和Bean Validation的架构思想。

		Chapter2 实体约束的声明、校验

		Chapter3 方法约束的声明、校验

		Chapter6 自定义约束

	// done 2020-3-17 23:00:07	

2. 声明、校验实体类约束		







