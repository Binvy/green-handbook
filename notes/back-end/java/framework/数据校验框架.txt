# Java数据校验：

	## 背景说明： 

		### 为什么要进行数据校验？什么场景下会用到数据校验？

			- web应用前后台交互（表现层）

					- 数据可能不会校验
					- 跳过前段数据校验，直接修改按钮样式等，然后直接提交表单到后台（比如有些表单数据是必输时，才会显示提交按钮等，但是会有人直接F12修改样式/前台JS校验方法）
					- 抓包工具拦截请求，修改数据信息，提交后台
					- 有一些业务逻辑相关的数据，在前台校验不方便

			- 接口开发中（服务层）

				- 对外提供接口

					接口字段，有多有少，几个/十几个/几十个，每个字段又有很多校验，比如非空/数值大小/字符串长度/日期时间格式等等，校验逻辑都在代码中实现：
						1. 通用性校验，业务逻辑关联性低
						2. 接口修改时，难以维护（比如，有些错误，只要出现就直接返回； 有些错误，是最后整合所有错误，一起提供给客户端）
						3. 校验程序执行也是不容忽视的（特别是接口调用次数很多的时候）

				- 调用外部接口	
						
					有两种选择：
						1. 不做任何校验，直接调用，信息校验交给接口提供方，返回错误
						2. 自己做校验，校验不通过，直接返回，校验通过再调用接口

			- 数据持久化（数据层）

				在数据持久化前，进行校验


		### 可用框架： 各个场景下，有哪些数据校验的方式？

			- 纯手工代码校验： 校验字段较少时

			- SpringMVC校验： 

				@RequestParam @NotNull...

			- Spring校验： 	

			- Hibernate-Validator： 

		### 为什么我们使用Hibernate-Validator框架？

			- 实现了Bean Validation JSR-380规范

Hibernate Validator 6.0.17.Final ——— JSR 380 Reference Implementation

前言：

	数据校验是贯穿所有应用层级的通用任务，从表现层到持久层，每层的校验逻辑基本相同，如果都单独实现，一是浪费时间，另外也容易发生错误。
	为了避免重复校验，开发一般会将校验逻辑直接绑定到实体类，但是实体类本身通常属于一个固定不变的元组件，添加校验代码后就会变得比较杂乱。


		Web页面  ————————  Controller展示层  ————————  Business业务层  ———————— DAO持久层  ————————  数据库
								\                                                  /
								 \________________________ java __________________/


	JSR 380 - Bean Validation - 定义了实体、方法校验的基础模型和API。 
	默认组件是使用注解，可以通过XML进行重写、扩展。 API也没有限制，配置/编码，Web层/持久层，server端/Swing端，均可以使用，

	Hibernate Validator就是JSR380的实现， 提供了对API、TCK的实现，在Apache Software License 2.0协议下开源。

1.开始

	前期准备：

		JDK1.8

		Maven

		有网（maven下载相关依赖使用）

	1.1 项目引入：

		pom.xml：

			<dependency>
				<groupId>org.hibernate.validator</groupId>
				<artifactId>hibernate-validator</artifactId>
				<version>6.0.17.Final</version>
			</dependency			

	1.2 使用约束：

		i.e：

			实体类：

				import javax.validation.constraints.Min;
				import javax.validation.constraints.NotNull;
				import javax.validation.constraints.Size;

				public class Car {

					@NotNull
					private String manufacturer;

					@NotNull
					@Size(min = 2, max = 14)
					private String licensePlate;

					@Min(2)
					private int seatCount;

					public Car(String manufacturer, String licencePlate, int seatCount) {
						this.manufacturer = manufacturer;
						this.licensePlate = licencePlate;
						this.seatCount = seatCount;
					}

					//getters and setters ...
				}

	1.3 校验约束：	

		i.e：	

			测试类：
			
				import java.util.Set;
				import javax.validation.ConstraintViolation;
				import javax.validation.Validation;
				import javax.validation.Validator;
				import javax.validation.ValidatorFactory;

				import org.junit.BeforeClass;
				import org.junit.Test;

				import static org.junit.Assert.assertEquals;

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void manufacturerIsNull() {
						Car car = new Car( null, "DD-AB-123", 4 );

						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );

						assertEquals( 1, constraintViolations.size() );
						assertEquals( "must not be null", constraintViolations.iterator().next().getMessage() );
					}

					@Test
					public void licensePlateTooShort() {
						Car car = new Car( "Morris", "D", 4 );

						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );

						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								"size must be between 2 and 14",
								constraintViolations.iterator().next().getMessage()
						);
					}

					@Test
					public void seatCountTooLow() {
						Car car = new Car( "Morris", "DD-AB-123", 1 );

						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );

						assertEquals( 1, constraintViolations.size() );
						assertEquals(
								"must be greater than or equal to 2",
								constraintViolations.iterator().next().getMessage()
						);
					}

					@Test
					public void carIsValid() {
						Car car = new Car( "Morris", "DD-AB-123", 2 );

						Set<ConstraintViolation<Car>> constraintViolations =
								validator.validate( car );

						assertEquals( 0, constraintViolations.size() );
					}
				}	

	1.4 推荐阅读

		Chapter14 Funter reading: Hibernate Validator和Bean Validation的架构思想。

		Chapter2 实体约束的声明、校验

		Chapter3 方法约束的声明、校验

		Chapter6 自定义约束

	// done 2020-3-17 23:00:07	

2. 声明、校验实体约束

3. 声明、校验方法约束 		

4. 添加约束的错误消息

	4.1 默认消息

		消息参数: {}
		消息表达式: ${}

		解析规则：

			1. 国际化

				ValidationMessage.properties
				ValidationMessage_en_US.properties
				ValidationMessage_zh_CN.properties

			2. ValidationMessages	

			3. 约束属性值
			
				Size#min(): must not be least {min}

			4. EL表达式	

		4.1.1 转义字符
		
			\{ -> {
			\} -> }
			\$ -> $
			\\ -> \

		4.1.2 添加消息表达式	 

			EL表达式中可用的内容：

				- 约束中的属性值: 属性名称
				- 当前校验值（属性、对象、方法参数等等）: validatedValue
				- 对象映射: format(String format, Object... args) 类似 java.util.Formatter.format(String format, Object... args)

		4.1.3 例子

			实体类：

				public class Car {

					@NotNull
					private String manufacturer;

					@Size(
							min = 2,
							max = 14,
							message = "The license plate '${validatedValue}' must be between {min} and {max} characters long"
					)
					private String licensePlate;

					@Min(
							value = 2,
							message = "There must be at least {value} seat${value > 1 ? 's' : ''}"
					)
					private int seatCount;

					@DecimalMax(
							value = "350",
							message = "The top speed ${formatter.format('%1$.2f', validatedValue)} is higher " +
									"than {value}"
					)
					private double topSpeed;

					@DecimalMax(value = "100000", message = "Price must not be higher than ${value}")
					private BigDecimal price;

					public Car(
							String manufacturer,
							String licensePlate,
							int seatCount,
							double topSpeed,
							BigDecimal price) {
						this.manufacturer = manufacturer;
						this.licensePlate = licensePlate;
						this.seatCount = seatCount;
						this.topSpeed = topSpeed;
						this.price = price;
					}

					//getters and setters ...
				}

			测试类：

				public class CarTest {

					private static Validator validator;

					@BeforeClass
					public static void setUpValidator() {
						ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
						validator = factory.getValidator();
					}

					@Test
					public void messageDescriptors() {
						//tag::messageDescriptors[]
						Car car = new Car( null, "A", 1, 400.123456, BigDecimal.valueOf( 200000 ) );

						String message = validator.validateProperty( car, "manufacturer" )
								.iterator()
								.next()
								.getMessage();
						assertEquals( "must not be null", message );

						message = validator.validateProperty( car, "licensePlate" )
								.iterator()
								.next()
								.getMessage();
						assertEquals(
								"The license plate 'A' must be between 2 and 14 characters long",
								message
						);

						message = validator.validateProperty( car, "seatCount" ).iterator().next().getMessage();
						assertEquals( "There must be at least 2 seats", message );

						message = validator.validateProperty( car, "topSpeed" ).iterator().next().getMessage();
						assertEquals( "The top speed 400.12 is higher than 350", message );

						message = validator.validateProperty( car, "price" ).iterator().next().getMessage();
						assertEquals( "Price must not be higher than $100000", message );
						//end::messageDescriptors[]
					}
				}

	4.2	自定义消息

		实现：
	
			实现接口： java.validation.MessageInterpolator

			默认实现： Configuration#getDefaultMessageInterpolator()

		配置方法：

			- validation.xml

			- ValidatorFactory / Validator

		4.2.1 资源绑定地址：	

			- 默认

				Validator validator = Validation.byDefaultProvider()
						.configure()
						.messageInterpolator(
								new ResourceBundleMessageInterpolator(
										new PlatformResourceBundleLocator( "MyMessages" )
								)
						)
						.buildValidatorFactory()
						.getValidator();

			- 综合			

				Validator validator = Validation.byDefaultProvider()
				.configure()
				.messageInterpolator(
						new ResourceBundleMessageInterpolator(
								new AggregateResourceBundleLocator(
										Arrays.asList(
												"MyMessages",
												"MyOtherMessages"
										)
								)
						)
				)
				.buildValidatorFactory()
				.getValidator();

	// done 2020-3-21 15:21:00					













