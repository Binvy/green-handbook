《深入理解Java虚拟机————JVM高级特性与最佳实践》

// 2019-8-4 11:22:02 start

第1部分 走进java

	第1章 走进java

		1.1 概述

		1.2 java技术体系

		1.3 java发展史

		1.4 java虚拟机发展史

		1.5 展望java技术的未来

		1.6 实战：自己编译jdk

		1.7 本章小结

第2部分 自动内存管理机制										// start 2019-9-9 20:58:25

	第2章 Java内存区域与内存溢出异常

		2.1 概述												// done 2019-9-9 21:00:27

		2.2 运行时数据区域									

							            运行时数据区
			 ______________________________________________________________________				
			|	_________________    ________________     _____________________   |
			|  |      方法区     |   |   虚拟机栈     |    |    本地方法栈       |  |
			|  |   Method Area   |  |   VM Stack     |   | Native Method Stack |  |
			|  |_________________|	|________________|	 |_____________________|  |	
			|  _________________     __________________________________________   |
			|  |       堆       |   |               程序计数器                  |  |
			|  |      Heap      |   |           Program Counter Register       |  |
			|  |________________|   |__________________________________________|  |
			|_____________________________________________________________________|
			|         ↓  ↑                     ↓  ↑                               |
			|  _______↓__↑______      _________↓__↑__________                     |
			|  |               |     |                       |                    |
			|  |    执行引擎    |___\ |       本地库接口       |________\本地方法库  |
			|  |_______________|   / |_______________________|        /           |
			|_____________________________________________________________________|	

			2.2.1 程序计数器

				可以看做是当前线程执行的字节码的行号指示器

			2.2.2 Java虚拟机栈

				描述的是Java方法执行的内存模型：
					每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
					每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

				如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
				如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

			2.2.3 本地方法栈

				虚拟机栈：为虚拟机执行java方法（字节码）服务
				本地方法栈：为虚拟机使用到的Native方法服务

			2.2.4 堆

				唯一目的：存放对象实例，几乎所有的对象实例都在这里分配内存。

				Java堆式垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。

			2.2.5 方法区

				各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

			2.2.6 运行时常量池

				方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

			2.2.7 直接内存									// done 2019-9-9 21:43:03								

		2.3 HotSpot虚拟机对象探秘

			2.3.1 对象的创建

				虚拟机遇到一条new命令时：

					1. 首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号应用代表的类是否已被加载、解析和初始化过。

						如果没有：那必须先执行响应的类加载过程。

					2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。

						假设Java堆中内存是规整的，则使用“指针碰撞”的分配方式。

						假设Java堆中内存不是规整的，则使用“空闲列表”的分配方法。

					3. 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）	

					4. 接下来，虚拟机要对对象进行必要的设置，如：对象属于哪个类、如果找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。

					都完成之后：

						虚拟机的视角：一个新的对象已经产生了。

						Java程序视角：对象创建才刚刚开始————<init>方法还没有执行，所有的字段都还为零。

					5. 执行<init>方法，将对象进行初始化，这样一个真正的对象才算完成。

			2.3.2 对象的内存布局

				HotSpot虚拟中中，对象在内存中存储的布局可以分为3块区域：

					1. 对象头（Header）

						第一部分： 存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等

						第二部分： 类型指针，即对象指向它的类元数据的指针。

					2. 实例数据（Instance Data）

						对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。

					3. 对其填充（Padding）

						不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。

			2.3.3 对象的访问定位								// done 2019-9-9 21:53:54

				主流的访问方式有两种，分别是：

					1. 使用句柄

						Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的地址信息。

						优点： reference中存储的是稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针，reference本身不需要修改。

					2. 直接指针

						Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。

						优点： 速度更快，节省了一次指针定位的时间开销。

		2.4 实战：OutOfMemoryError异常
		
			2.4.1 Java堆溢出

			2.4.2 虚拟机栈和本地方法栈溢出

			2.4.3 方法区和运行时常量池溢出

			2.4.4 本机直接内存溢出							// done 2019-9-9 22:06:37

		2.5 本章小结											// done 2019-9-9 22:06:51

															// nothing but lol 2019-9-10 23:38:23

	第3章 垃圾收集器与内存分配策略								// done 2019-9-13 10:31:49

		3.1 概述

		3.2 对象已死吗

			3.2.1 引用计数算法

			3.2.2 可达性分析算法

			3.2.3 再谈引用

			3.2.4 生存还是死亡

			3.2.5 回收方法区

		3.3 垃圾收集算法

			3.3.1 标记-清除算法

			3.3.2 复制算法

			3.3.3 标记-整理算法

			3.3.4 分代收集算法

		3.4 Hotspot的算法实现

			3.4.1 枚举根节点

			3.4.2 安全点

			3.4.3 安全区域

		3.5 垃圾收集器

			3.5.1 Serial收集器

			3.5.2 ParNew收集器

			3.5.3 Parallel Scavenge收集器

			3.5.4 Serial Old收集器

			3.5.6 CMS（Concurrent Mark Sweep）收集器

			3.5.7 G1（Garbage-First）收集器

			3.5.8 理解GC日志

			3.5.9 垃圾收集器参数总结

		3.6 对象分配和回收策略

			3.6.1 对象优先在Eden分配

			3.6.2 大对象直接进入老年代

			3.6.3 长期存活的对象将进入老年代

			3.6.4 动态对象年龄判定

			3.6.5 空间分配担保

		3.7 本章小结									// done 2019-9-13 11:44:40			

	第4章 虚拟机性能监控与故障处理工具					// done 2019-9-14 12:03:41

		4.1 概述

		4.2 jdk的命令行工具

			4.2.1 jps: 虚拟机进程工具

			4.2.2 jstat: 虚拟机统计信息监视工具

			4.2.3 jinfo: java配置信息工具

			4.2.4 jmap: java内存映像工具

			4.2.5 jhat: 虚拟机堆转储快照分析工具

			4.2.6 jstack: java堆栈跟踪工具

			4.2.7 hsdis: jit生成代码反汇编

		4.3 jdk的可视化工具

			4.3.1 jconsole: java监视与管理控制台

			4.3.2 jvisualvm: 多合一故障处理工具

		4.4 本章小结									// done 2019-9-14 12:04:26

	第5章 调优案例分析与实战							// done 2019-9-15 10:38:51

		5.1 概述

		5.2 案例分析

			5.2.1 高性能硬件上的程序部署策略

			5.2.2 集群间同步导致的内存溢出

			5.2.3 堆外内存导致的溢出错误

			5.2.4 外部命令导致系统缓慢

			5.2.5 服务器jvm进程崩溃

			5.2.6 不恰当数据结构导致内存占用过大

			5.2.7 由Windows虚拟内存导致的长时间停顿

		5.3 实战：Eclipse运行速度调优

			5.3.1 调优前的程序运行状态

			5.3.2 升级jdk1.6的性能变化及兼容问题

			5.3.3 编译时间和类加载时间的优化

			5.3.4 调整内存设置控制垃圾收集频率 

			5.3.5 选择收集器降低延迟

				Eclipse.ini配置++

					-Xverify:none 							// 禁止掉字节码验证过程
					-Xmx512m 								// Java堆容量默认值
					-Xms512m 								// Java堆最大容量
					-Xmn128m 								// Java新生代容量默认值
					-XX:PermSize=96m 						// 永久代容量默认值
					-XX:MaxPermSize=96m 					// 永久代最大容量
					-XX:+DisableExplicitGC 					// 屏蔽System.gc()
					-Xnoclassgc 							// 关闭虚拟机对class的垃圾回收功能
					-XX:+UseParNewGC 						// 默认的新生代收集器
					-XX:+UseConcMarkSweepGC 				// 默认使用CMS收集器
					-XX:CMSInitiatingOccupancyFraction=85 	// CMS垃圾收集器，当老年代达到85%时，触发CMS垃圾回收

		5.4 本章小结

第三部分	虚拟机执行子系统								// done 2019-9-16 23:35:11

	第6章 类文件结构

		6.1 概述										// done 2019-9-16 21:26:04

		6.2 无关性的基石								// done 2019-9-16 21:26:10
		
		6.3 class类文件的结构							// done 2019-9-16 23:00:30

			ClassFile {
			    u4             magic;
			    u2             minor_version;
			    u2             major_version;
			    u2             constant_pool_count;
			    cp_info        constant_pool[constant_pool_count-1];
			    u2             access_flags;
			    u2             this_class;
			    u2             super_class;
			    u2             interfaces_count;
			    u2             interfaces[interfaces_count];
			    u2             fields_count;
			    field_info     fields[fields_count];
			    u2             methods_count;
			    method_info    methods[methods_count];
			    u2             attributes_count;
			    attribute_info attributes[attributes_count];
			}		

			6.3.1 魔数与calss文件的版本

			6.3.2 常量池

			6.3.3 访问标识

				javap -verbose TestClass

			6.3.4 类索引、父类索引和接口索引集合

			6.3.5 字段表结合

			6.3.6 方法表集合

			6.3.7 属性表集合

		6.4 字节码指令简介									// done 2019-9-16 23:32:12

			6.4.1 字节码和数据类型

			6.4.2 加载和存储指令

			6.4.3 运算指令

			6.4.4 类型转换指令

			6.4.5 对象创建和访问指令

			6.4.6 操作数栈管理指令
 
			6.4.7 控制转移指令

			6.4.8 方法调用和返回指令

			6.4.9 异常处理指令

			6.4.10 同步指令

		6.5 公有设计和私有实现								// done 2019-9-16 23:33:48

		6.6 class文件结构的发展								// done 2019-9-16 23:34:56

		6.7 本章小结											// done 2019-9-16 23:35:03

	第7章 虚拟机类加载机制 									// done 2019-9-18 00:04:22

		7.1 概述

			虚拟机的类加载机制：虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。

		7.2 类加载的时机

		7.3 类加载的过程

			7.3.1 加载

			7.3.2 验证

			7.3.3 准备

			7.3.4 解析

			7.3.5 初始化

		7.4 类加载器

			7.4.1 类与类加载器

			7.4.2 双亲委派模型

			7.4.3 破坏双亲委派模型 

		7.5 本章小结

	第8章 虚拟机字节码执行引擎

		8.1 概述

		8.2 运行时栈帧结构

			8.2.1 局部变量表

			8.2.2 操作数栈

			8.2.3 动态连接

			8.2.4 方法返回地址

			8.2.5 附加信息

		8.3 方法调用

			8.3.1 解析

			8.3.2 分派

			8.3.3 动态类语言支持

		8.4 基于栈的字节码解释执行引擎

			8.4.1 解释执行

			8.4.2 基于栈的指令集与基于寄存器的指令集

			8.4.3 基于栈的解释器执行过程

		8.5 本章小结

	第9章 类加载及执行子系统的案例和实战

		9.1 概述

		9.2 案例分析

			9.2.1 tomcat:正统的类加载架构

			9.2.2 osgi:灵活的类加载架构

			9.2.3 字节码生成技术与动态代理的实现

			9.2.4 retrotranslator:跨域jdk版本

		9.3 实战：自己动手实现远程执行功能

			9.3.1 目标

			9.3.2 思路

			9.3.3 实现

			9.3.4 验证

		9.4 本章小结

第四部分 程序编译和代码优化

	第10章 早期（编译器）优化

		10.1 概述

		10.2 javac编译器

			10.2.1 javac的源码与调试

			10.2.2 解析与填充符号表

			10.2.3 注解处理器

			10.2.4 语义分析与字节码生成

		10.3 java语法糖的味道

			10.3.1 泛型与类型擦除

			10.3.2 自动装箱、拆箱与遍历循环

			10.3.3 条件编译

		10.4 实战：插入式注解处理器

			10.4.1 实战目标

			10.4.2 代码实现

			10.4.3 运行与测试

			10.4.4 其他应用案例

		10.5 本站小结

	第11章 晚期（运行期）优化

		11.1 概述

		11.2 hotspot虚拟机内的即时编译器

			11.2.1 解释器与编译器

			11.2.2 编译对象与触发条件

			11.2.3 编译过程

			11.2.4 查看及分析即时编译结果

		11.3 编译优化技术

			11.3.1 优化技术概览

			11.3.2 公共子表达式消除

			11.3.3 数组边界检查消除

			11.3.4 方法内联

			11.3.5 逃逸分析

		11.4 java与c++编译器对比

		11.5 本章小结

第五部分 高效并发		

	第12章 java内存模型与线程

		12.1 概述

		12.2 硬件的效率与一致性

		12.3 java内存模型

			12.3.1 主内存和工作内存
			
			12.3.2 内存间相互操作

			12.3.3 对于volatile型变量的特殊规则

			12.3.4 对于long和double型变量的特殊规则

			12.3.5 原子性、可见性和有序性

			12.3.6 先行发生规则

		12.4 java与线程

			12.4.1 线程的实现

			12.4.2 java线程调度

			12.4.3 状态转换

		12.5 本章小结

	第13章 线程安全和锁优化

		13.1 概述

		13.2 线程安全

			13.2.1 java语言中的线程安全

			13.2.2 线程安全的实现方法

		13.3 锁优化

			13.3.1 自旋锁和自适应自旋

			13.3.2 锁消除

			13.3.3 锁优化

			13.3.4 轻量级锁

			13.3.5 偏向锁

		13.4 本章小结	