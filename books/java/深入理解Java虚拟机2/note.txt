《深入理解Java虚拟机————JVM高级特性与最佳实践》

// 2019-8-4 11:22:02 start

第1部分 走进java

	第1章 走进java

		1.1 概述

		1.2 java技术体系

		1.3 java发展史

		1.4 java虚拟机发展史

		1.5 展望java技术的未来

		1.6 实战：自己编译jdk

		1.7 本章小结

第2部分 自动内存管理机制										// start 2019-9-9 20:58:25

	第2章 Java内存区域与内存溢出异常

		2.1 概述												// done 2019-9-9 21:00:27

		2.2 运行时数据区域									

							            运行时数据区
			 ______________________________________________________________________				
			|	_________________    ________________     _____________________   |
			|  |      方法区     |   |   虚拟机栈     |    |    本地方法栈       |  |
			|  |   Method Area   |  |   VM Stack     |   | Native Method Stack |  |
			|  |_________________|	|________________|	 |_____________________|  |	
			|  _________________     __________________________________________   |
			|  |       堆       |   |               程序计数器                  |  |
			|  |      Heap      |   |           Program Counter Register       |  |
			|  |________________|   |__________________________________________|  |
			|_____________________________________________________________________|
			|         ↓  ↑                     ↓  ↑                               |
			|  _______↓__↑______      _________↓__↑__________                     |
			|  |               |     |                       |                    |
			|  |    执行引擎    |___\ |       本地库接口       |________\本地方法库  |
			|  |_______________|   / |_______________________|        /           |
			|_____________________________________________________________________|	

			2.2.1 程序计数器

				可以看做是当前线程执行的字节码的行号指示器

			2.2.2 Java虚拟机栈

				描述的是Java方法执行的内存模型：
					每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
					每一个方法从调用直至执行完毕的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程。

				如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常。
				如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。

			2.2.3 本地方法栈

				虚拟机栈：为虚拟机执行java方法（字节码）服务
				本地方法栈：为虚拟机使用到的Native方法服务

			2.2.4 堆

				唯一目的：存放对象实例，几乎所有的对象实例都在这里分配内存。

				Java堆式垃圾收集器管理的主要区域，因此很多时候也被称作“GC堆”。

			2.2.5 方法区

				各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

			2.2.6 运行时常量池

				方法区的一部分，用于存放编译期生成的各种字面量和符号引用。

			2.2.7 直接内存									// done 2019-9-9 21:43:03								

		2.3 HotSpot虚拟机对象探秘

			2.3.1 对象的创建

				虚拟机遇到一条new命令时：

					1. 首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号应用代表的类是否已被加载、解析和初始化过。

						如果没有：那必须先执行响应的类加载过程。

					2. 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。

						假设Java堆中内存是规整的，则使用“指针碰撞”的分配方式。

						假设Java堆中内存不是规整的，则使用“空闲列表”的分配方法。

					3. 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）	

					4. 接下来，虚拟机要对对象进行必要的设置，如：对象属于哪个类、如果找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。

					都完成之后：

						虚拟机的视角：一个新的对象已经产生了。

						Java程序视角：对象创建才刚刚开始————<init>方法还没有执行，所有的字段都还为零。

					5. 执行<init>方法，将对象进行初始化，这样一个真正的对象才算完成。

			2.3.2 对象的内存布局

				HotSpot虚拟中中，对象在内存中存储的布局可以分为3块区域：

					1. 对象头（Header）

						第一部分： 存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等

						第二部分： 类型指针，即对象指向它的类元数据的指针。

					2. 实例数据（Instance Data）

						对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。

					3. 对其填充（Padding）

						不是必然存在的，也没有特别的含义，仅仅起着占位符的作用。

			2.3.3 对象的访问定位								// done 2019-9-9 21:53:54

				主流的访问方式有两种，分别是：

					1. 使用句柄

						Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的地址信息。

						优点： reference中存储的是稳定的句柄地址，对象被移动时只会改变句柄中的实例数据指针，reference本身不需要修改。

					2. 直接指针

						Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。

						优点： 速度更快，节省了一次指针定位的时间开销。

		2.4 实战：OutOfMemoryError异常
		
			2.4.1 Java堆溢出

			2.4.2 虚拟机栈和本地方法栈溢出

			2.4.3 方法区和运行时常量池溢出

			2.4.4 本机直接内存溢出							// done 2019-9-9 22:06:37

		2.5 本章小结											// done 2019-9-9 22:06:51

															// nothing but lol 2019-9-10 23:38:23

	第3章 垃圾收集器与内存分配策略								// done 2019-9-13 10:31:49

		3.1 概述

		3.2 对象已死吗

			3.2.1 引用计数算法

			3.2.2 可达性分析算法

			3.2.3 再谈引用

			3.2.4 生存还是死亡

			3.2.5 回收方法区

		3.3 垃圾收集算法

			3.3.1 标记-清除算法

			3.3.2 复制算法

			3.3.3 标记-整理算法

			3.3.4 分代收集算法

		3.4 Hotspot的算法实现

			3.4.1 枚举根节点

			3.4.2 安全点

			3.4.3 安全区域

		3.5 垃圾收集器

			3.5.1 Serial收集器

			3.5.2 ParNew收集器

			3.5.3 Parallel Scavenge收集器

			3.5.4 Serial Old收集器

			3.5.6 CMS（Concurrent Mark Sweep）收集器

			3.5.7 G1（Garbage-First）收集器

			3.5.8 理解GC日志

			3.5.9 垃圾收集器参数总结

		3.6 对象分配和回收策略

			3.6.1 对象优先在Eden分配

			3.6.2 大对象直接进入老年代

			3.6.3 长期存活的对象将进入老年代

			3.6.4 动态对象年龄判定

			3.6.5 空间分配担保

		3.7 本章小结									// done 2019-9-13 11:44:40			

	第4章 虚拟机性能监控与故障处理工具

	第5章 调优案例分析与实战	